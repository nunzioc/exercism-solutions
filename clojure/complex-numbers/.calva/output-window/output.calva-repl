; This is the Calva evaluation results output window.
; TIPS: The keyboard shortcut `ctrl+alt+o o` shows and focuses this window
;   when connected to a REPL session.
; Please see https://calva.io/output/ for more info.
; Happy coding! ♥️

; Jacking in...
; Starting Jack-in Terminal: lein update-in :dependencies conj '[nrepl,"0.9.0"]' -- update-in :plugins conj '[cider/cider-nrepl,"0.27.4"]' -- update-in '[:repl-options,:nrepl-middleware]' conj '["cider.nrepl/cider-middleware"]' -- repl :headless
; Hooking up nREPL sessions...
; Connected session: clj
; TIPS: 
;   - You can edit the contents here. Use it as a REPL if you like.
;   - `alt+enter` evaluates the current top level form.
;   - `ctrl+enter` evaluates the current form.
;   - `alt+up` and `alt+down` traverse up and down the REPL command history
;      when the cursor is after the last contents at the prompt
;   - Clojure lines in stack traces are peekable and clickable.
clj꞉user꞉>  ; Use `alt+enter` to evaluate
; Jack-in done.
clj꞉user꞉> 
#'complex-numbers/imaginary
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers_test.clj
; Syntax error compiling at (complex_numbers_test.clj:40:12).
; No such var: c/abs
; Evaluation of file complex_numbers_test.clj failed: class clojure.lang.Compiler$CompilerException
#'complex-numbers/div
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers_test.clj
#'complex-numbers-test/divide-numbers-with-real-and-imaginary-part
; Running tests for complex-numbers-test...
; FAIL in complex-numbers-test/absolute-of-negative-purely-imaginary-number (complex_numbers_test.clj:55):
; Absolute value of a purely imaginary number with negative imaginary part
; expected:
(= (c/abs [0 -5]) 5.0)
; actual:
(not (= nil 5.0))
; FAIL in complex-numbers-test/absolute-of-negative-purely-real-number (complex_numbers_test.clj:45):
; Absolute value of a negative purely real number
; expected:
(= (c/abs [-5 0]) 5.0)
; actual:
(not (= nil 5.0))
; FAIL in complex-numbers-test/absolute-of-positive-purely-imaginary-number (complex_numbers_test.clj:50):
; Absolute value of a purely imaginary number with positive imaginary part
; expected:
(= (c/abs [0 5]) 5.0)
; actual:
(not (= nil 5.0))
; FAIL in complex-numbers-test/absolute-of-positive-purely-real-number (complex_numbers_test.clj:40):
; Absolute value of a positive purely real number
; expected:
(= (c/abs [5 0]) 5.0)
; actual:
(not (= nil 5.0))
; FAIL in complex-numbers-test/absolute-of-real-and-imaginary-number (complex_numbers_test.clj:60):
; Absolute value of a number with real and imaginary part
; expected:
(= (c/abs [3 4]) 5.0)
; actual:
(not (= nil 5.0))
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
(= (c/add [1 2] [3 4]) [4 6])
; actual:
(not (= nil [4 6]))
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
(= (c/add [0 1] [0 2]) [0 3])
; actual:
(not (= nil [0 3]))
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
(= (c/add [1 0] [2 0]) [3 0])
; actual:
(not (= nil [3 0]))
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
(= (c/conjugate [0 5]) [0 -5])
; actual:
(not (= nil [0 -5]))
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
(= (c/conjugate [5 0]) [5 0])
; actual:
(not (= nil [5 0]))
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
(= (c/conjugate [1 1]) [1 -1])
; actual:
(not (= nil [1 -1]))
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
(= (c/div [1 2] [3 4]) [0.44 0.08])
; actual:
(not (= nil [0.44 0.08]))
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
(= (c/div [1 0] [2 0]) [0.5 0.0])
; actual:
(not (= nil [0.5 0.0]))
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; actual:
(not (= nil [0.5 0.0]))
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
(= (c/mul [1 2] [3 4]) [-5 10])
; actual:
(not (= nil [-5 10]))
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
(= (c/mul [0 1] [0 2]) [-2 0])
; actual:
(not (= nil [-2 0]))
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
(= (c/mul [1 0] [2 0]) [2 0])
; actual:
(not (= nil [2 0]))
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
(= (c/sub [1 2] [3 4]) [-2 -2])
; actual:
(not (= nil [-2 -2]))
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
(= (c/sub [0 1] [0 2]) [0 -1])
; actual:
(not (= nil [0 -1]))
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
(= (c/sub [1 0] [2 0]) [-1 0])
; actual:
(not (= nil [-1 0]))
; 26 tests finished, problems found. 😭 errors: 0, failures: 20, ns: 1, vars: 26
clj꞉complex-numbers-test꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/absolute-of-negative-purely-imaginary-number (complex_numbers_test.clj:55):
; Absolute value of a purely imaginary number with negative imaginary part
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-negative-purely-real-number (complex_numbers_test.clj:45):
; Absolute value of a negative purely real number
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-imaginary-number (complex_numbers_test.clj:50):
; Absolute value of a purely imaginary number with positive imaginary part
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-real-number (complex_numbers_test.clj:40):
; Absolute value of a positive purely real number
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-real-and-imaginary-number (complex_numbers_test.clj:60):
; Absolute value of a number with real and imaginary part
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
nil
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
nil
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
nil
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 20, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
; Syntax error compiling at (complex_numbers.clj:10:3).
; Unable to resolve symbol: square-root in this context
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/absolute-of-negative-purely-imaginary-number (complex_numbers_test.clj:55):
; Absolute value of a purely imaginary number with negative imaginary part
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-negative-purely-real-number (complex_numbers_test.clj:45):
; Absolute value of a negative purely real number
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-imaginary-number (complex_numbers_test.clj:50):
; Absolute value of a purely imaginary number with positive imaginary part
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-real-number (complex_numbers_test.clj:40):
; Absolute value of a positive purely real number
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-real-and-imaginary-number (complex_numbers_test.clj:60):
; Absolute value of a number with real and imaginary part
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
nil
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
nil
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
nil
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 20, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
(doc-find +)
; Syntax error compiling at (output.calva-repl:408:1).
; Unable to resolve symbol: doc-find in this context
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/absolute-of-negative-purely-imaginary-number (complex_numbers_test.clj:55):
; Absolute value of a purely imaginary number with negative imaginary part
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-negative-purely-real-number (complex_numbers_test.clj:45):
; Absolute value of a negative purely real number
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-imaginary-number (complex_numbers_test.clj:50):
; Absolute value of a purely imaginary number with positive imaginary part
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-real-number (complex_numbers_test.clj:40):
; Absolute value of a positive purely real number
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-real-and-imaginary-number (complex_numbers_test.clj:60):
; Absolute value of a number with real and imaginary part
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
nil
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
nil
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
nil
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 20, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
; Syntax error (ClassNotFoundException) compiling at (complex_numbers.clj:2:1).
; clojure.repl
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (ClassNotFoundException) compiling at (complex_numbers.clj:2:1).
; clojure.repl
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/absolute-of-negative-purely-imaginary-number (complex_numbers_test.clj:55):
; Absolute value of a purely imaginary number with negative imaginary part
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-negative-purely-real-number (complex_numbers_test.clj:45):
; Absolute value of a negative purely real number
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-imaginary-number (complex_numbers_test.clj:50):
; Absolute value of a purely imaginary number with positive imaginary part
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-real-number (complex_numbers_test.clj:40):
; Absolute value of a positive purely real number
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-real-and-imaginary-number (complex_numbers_test.clj:60):
; Absolute value of a number with real and imaginary part
; expected:
()
; actual:
5.0
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
nil
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
nil
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
nil
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 20, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
(require clojure.repl :as r)
; Syntax error (ClassNotFoundException) compiling at (output.calva-repl:670:1).
; clojure.repl
clj꞉complex-numbers꞉> 
(require '[clojure.repl :as r])
nil
clj꞉complex-numbers꞉> 
(r/find-doc +)
; Execution error (ClassCastException) at complex-numbers/eval10520 (form-init9252250445224228245.clj:677).
; class clojure.core$_PLUS_ cannot be cast to class java.lang.String (clojure.core$_PLUS_ is in unnamed module of loader 'app'; java.lang.String is in module java.base of loader 'bootstrap')
clj꞉complex-numbers꞉> 
(r/find-doc "+")
; Execution error (PatternSyntaxException) at java.util.regex.Pattern/error (Pattern.java:2027).
; Dangling meta character '+' near index 0
+
^
clj꞉complex-numbers꞉> 
(r/find-doc map)
; Execution error (ClassCastException) at complex-numbers/eval10524 (form-init9252250445224228245.clj:685).
; class clojure.core$map cannot be cast to class java.lang.String (clojure.core$map is in unnamed module of loader 'app'; java.lang.String is in module java.base of loader 'bootstrap')
clj꞉complex-numbers꞉> 
(r/find-doc "map")
-------------------------
nrepl.middleware.interruptible-eval/evaluate
([{:keys [transport session eval ns code file line column out-limit], :as msg}])
  Evaluates a msg's code within the dynamic context of its session.

   Uses `clojure.main/repl` to drive the evaluation of :code (either a string
   or a seq of forms to be evaluated), which may also optionally specify a :ns
   (resolved via `find-ns`).  The map MUST contain a Transport implementation
   in :transport; expression results and errors will be sent via that Transport.

   Note: we are doubling up on restoring of ctxcl in a `catch` block both here
   and within `misc/with-session-classloader`. Not too sure why this is needed,
   but it does seem to be a fix for https://github.com/nrepl/nrepl/issues/206
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.info/info
([ns sym] [ns sym params])
  Provide the info map for the input ns and sym.

  The default dialect is :clj but it can be specified as part of params.

  Note that the :cljs dialect requires the compiler state to be passed
  in as :env key in params.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.info/info*
([params])
  Provide the info map for the input ns and sym.

  The default dialect is :clj but it can be specified as part of params.

  Note that the :cljs dialect requires the compiler state to be passed
  in as :env key in params.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.info/javadoc-info
([path])
  Resolve a relative javadoc path to a URL and return as a map. Prefer javadoc
  resources on the classpath; then use online javadoc content for core API
  classes. If no source is available, return the relative path as is.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.spec/ns-name->ns-alias
([ns])
  Return mapping from full namespace name to its alias in the given namespace.
-------------------------
cider.nrepl.inlined-deps.compliment.v0v3v12.compliment.context/parse-context
([context])
  Takes a context which is a Lisp form and returns a transformed context.

  The result is a list of maps, each map represents a level of the
  context from inside to outside. Map has `:idx` and `:form` values,
  and `:map-role` if the level is a map. `:idx` defines the position
  of prefix (or the form containing prefix) on the current
  level (number for lists and vectors, key or value for maps).

  Example: `(dotimes [i 10] ({:foo {:baz __prefix__}, :bar 42} :quux))`

  Transformed it looks like:

  `({:idx :baz, :map-role :value, :form {:baz __prefix__}}
    {:idx :foo, :map-role :key, :form {:foo {:baz __prefix__}, :bar 42}}
    {:idx 0, :form ({:foo {:baz __prefix__}, :bar 42} :quux)}
    {:idx 2, :form (dotimes [i 10] ({:foo {:baz __prefix__}, :bar 42} :quux))})`.
-------------------------
cider.nrepl.middleware.track-state/calculate-changed-ns-map
([new-map old-map])
  Return a map of namespaces that changed between new-map and old-map.
  new-map and old-map are maps from namespace names to namespace data,
  which is the same format of map returned by this function. old-map
  can also be nil, which is the same as an empty map.
-------------------------
cider.nrepl.middleware.track-state/ensure-clojure-core-present
([old-ns-map project-ns-map cljs])
  Check if `old-ns-map` has clojure.core, else add it to
  current-ns-map. If `cljs` we inject cljs.core instead. `cljs` is the
  cljs environment grabbed from the message (if present).
-------------------------
cider.nrepl.middleware.track-state/merge-used-aliases
([new-ns-map old-ns-map val-fn])
  Return new-ns-map merged with all of its direct dependencies.
  val-fn a function that returns namespace objects when called with
  namespace names.
-------------------------
cider.nrepl.middleware.track-state/ns-cache
  Cache of the namespace info that has been sent to each session.
  Each key is a session. Each value is a map from namespace names to
  data (as returned by `ns-as-map`).
-------------------------
cider.nrepl.middleware.track-state/update-and-send-cache
([old-data msg] [old-data msg jar-ns-fn transport-send-fn])
  Send a reply to msg with state information assoc'ed.
  old-data is the ns-cache that needs to be updated (the one
  associated with msg's session). Return the updated value for it.
  This function has side-effects (sending the message)!

  Two extra entries are sent in the reply. One is the :repl-type,
  which is either :clj or :cljs.

  The other is :changed-namespaces, which is a map from namespace
  names to namespace data (as returned by `ns-as-map`). This contains
  only namespaces which have changed since we last notified the
  client.

  The 2-arity call is the intended way to use this function.

  The 4-arity call is provided for testing under mranderson.
  Allows substitution of supporting fns in the implementation that
  don't need to exposed otherwise. Be aware when the implementation
  details change because this arity (and the tests) will need to
  change also.
-------------------------
clojure.stacktrace/print-throwable
([tr])
  Prints the class and message of a Throwable. Prints the ex-data map
  if present.
-------------------------
cider.nrepl.inlined-deps.suitable.v0v4v1.suitable.compliment.sources.cljs.analysis/imports
([env ns])
  Returns a map of [import-name] to [ns-qualified-import-name] for all imports
  in the given namespace.
-------------------------
cider.nrepl.inlined-deps.suitable.v0v4v1.suitable.compliment.sources.cljs.analysis/macro-ns-aliases
([env ns])
  Returns a map of [macro-ns-name-or-alias] to [macro-ns-name] for the given namespace.
-------------------------
cider.nrepl.inlined-deps.suitable.v0v4v1.suitable.compliment.sources.cljs.analysis/ns-aliases
([env ns])
  Returns a map {ns-name-or-alias ns-name} for the given namespace.
-------------------------
cider.nrepl.inlined-deps.suitable.v0v4v1.suitable.compliment.sources.cljs.analysis/ns-interns-from-env
([env ns])
  Given a namespace return all the var analysis maps. Analagous to
  clojure.core/ns-interns but returns var analysis maps not vars.

  Directly from cljs.analyzer.api.
-------------------------
cider.nrepl.inlined-deps.suitable.v0v4v1.suitable.compliment.sources.cljs.analysis/public-macros
([_env ns])
  Given a namespace return all the public var analysis maps. Analagous to
  clojure.core/ns-publics but returns var analysis maps not vars.

  Inspired by the ns-publics in cljs.analyzer.api.
-------------------------
cider.nrepl.inlined-deps.suitable.v0v4v1.suitable.compliment.sources.cljs.analysis/referred-macros
([env ns])
  Returns a map of [macro-name] to [ns-qualified-macro-name] for all referred
  macros in the given namespace.
-------------------------
cider.nrepl.inlined-deps.suitable.v0v4v1.suitable.compliment.sources.cljs.analysis/referred-vars
([env ns])
  Returns a map of [var-name] to [ns-qualified-var-name] for all referred vars
  in the given namespace.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.query/namespaces
([{:keys [project? load-project-ns?], :as ns-query}])
  Takes a map containing these keys:

  `:exactly` The namespaces returned should be exactly these.
  `:project?` If true, the namespaces should all belong to the project.
  `:load-project-ns?` If true, the project namespaces will be loaded if they are not already.
  `:has-tests?` If true, only return namespaces containing tests.
  `:include-regexps` A list of regexps which the namespaces must match.
  `:exclude-regexps` A list of regexps which the namespaces must not match.

  Returns a list of namespaces as `find-ns` would return them on the host.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.query/vars
([{:keys [ns-query private? test? include-meta-key exclude-meta-key search search-property manipulate-vars], :as var-query}])
  Takes a map containing these keys:
  `:ns-query` A ns-query as `namespaces` takes, used to filter namespaces which contain vars.
  `:private?` Include private vars in the results.
  `:test?` Filter to vars which are also tests.
  `:include-meta-key` A list of keywords searched for in the var's metadata, vars matching will be included.
  `:exclude-meta-key` A list of keywords searched for in the var's metadata, vars matching will be excluded.
  `:search` A regex to use for filtering vars, matches against `:search-property`.
  `:search-property` Either :doc or :name, defaults to `:name`.
  `:manipulate-vars` A callback run with the list of namespaces return by namespaces and the vars found within. Can be used to manipulate the list of vars before they are filtered.

  Returns a list of vars, as the type that `var` would return on the host.
-------------------------
clojure.test/file-position
([n])
  Returns a vector [filename line-number] for the nth call up the
  stack.

  Deprecated in 1.2: The information needed for test reporting is
  now on :file and :line keys in the result map.
-------------------------
clojure.test/inc-report-counter
([name])
  Increments the named counter in *report-counters*, a ref to a map.
  Does nothing if *report-counters* is nil.
-------------------------
clojure.test/report
  Generic reporting function, may be overridden to plug in
   different report formats (e.g., TAP, JUnit).  Assertions such as
   'is' call 'report' to indicate results.  The argument given to
   'report' will be a map with a :type key.  See the documentation at
   the top of test_is.clj for more information on the types of
   arguments for 'report'.
-------------------------
clojure.test/run-tests
([] [& namespaces])
  Runs all tests in the given namespaces; prints results.
  Defaults to current namespace if none given.  Returns a map
  summarizing test results.
-------------------------
cider.nrepl.middleware.test/report
  Handle reporting for test events.

  This takes a test event map as an argument and updates the `current-report`
  atom to reflect test results and summary statistics.
-------------------------
cider.nrepl.middleware.test/test-ns
([ns vars])
  If the namespace object defines a function named `test-ns-hook`, call that.
  Otherwise, test the specified vars. On completion, return a map of test
  results.
-------------------------
cider.nrepl.middleware.test/test-nss
([m])
  Call `test-ns` for each entry in map `m`, in which keys are namespace
  symbols and values are var symbols to be tested in that namespace (or `nil`
  to test all vars). Symbols are first resolved to their corresponding
  objects.
-------------------------
cider.nrepl.middleware.debug/*skip-breaks*
  Map used to determine whether to skip a breakpoint.
  Don't set or examine this directly, it is bound in the session binding map,
  use `skip-breaks!` and `skip-breaks?` instead. Its value is reset at the
  beginning each eval session.
-------------------------
cider.nrepl.middleware.debug/eval-with-locals
([form dbg-state])
  `eval` form wrapped in a let of the locals map.
  If an exception is thrown, it is caught and sent to the client, and this
  function returns nil. `dbg-state` is a metadata map received from `break'.
-------------------------
cider.nrepl.middleware.debug/locals-for-message
([locals])
  Prepare a map of local variables for sending through the repl.
-------------------------
cider.nrepl.middleware.debug/promises
  Map atom holding all unprocessed debug inputs.
This is where the "debug" op stores replies received for debug
input requests. `read-debug-input` will halt until it finds its input in
this map (identified by a key), and will `dissoc` it afterwards.
-------------------------
cider.nrepl.middleware.debug/read-debug-command
([coor value locals STATE__])
  Read and take action on a debugging command.
  Ask for one of the following debug commands using `read-debug-input`:

    next: Return value.
    continue: Skip the current breakpoint.
    continue-all: Skip breakpoints for the remainder of this eval session.
    in: Step into a function
    out: Skip breakpoints in the current sexp.
    here: Skip all breakpoints up till specified coordinate `coord`
    inspect: Inspect the current expression
    inspect-prompt: Prompt for an expression to evaluate and inspect it.
    locals: Inspect local variables.
    inject: Evaluate an expression and return it.
    eval: Evaluate an expression, display result, and prompt again.
    stacktrace: Print the current stacktrace, and prompt again.
    trace: Continue, printing intermediate expressions and their values.
    quit: Abort current eval session.

  Response received can be any one of these values. It can also be a map
  whose :response entry is one of these values, which can thus be used to
  provide additional pa
rameters. For instance, if this map has a :code entry,
  its value is used for operations such as :eval, which would otherwise
  interactively prompt for an expression.
-------------------------
cider.nrepl.middleware.debug/read-eval-expression
([prompt dbg-state] [prompt dbg-state code])
  Read and eval an expression from the client.
  `dbg-state` is a map received from `break`, and `prompt` is added into
  the :prompt key.
-------------------------
cider.nrepl.middleware.debug/sanitize-env
([env])
  Turn a macro's &env into a map usable for binding.
-------------------------
cider.nrepl.middleware.debug/skip-breaks?
([coor STATE__])
  True if the breakpoint at coordinates should be skipped.

  The `*skip-breaks*` map stores a `mode`, `coordinates`, the `code` that it
  applies to, and a `force?` flag.

  Behaviour depends on the `mode`:
   - :all - return true, skipping all breaks
   - :trace - return false, skip nothing
   - :deeper - return true if the given coordinates are deeper than the
               coordinates stored in `*skip-breaks*`, in the same code
   - :before - return true if the given coordinates represent a place before
               the coordinates in `*skip-breaks*`, in the same code

  For :deeper and :before, if we are not in the same code (i.e. we have stepped
  into another instrumented function and code argument doesn't match old code in
  *skip-breaks*), then return the value of `force?`.
-------------------------
cider.nrepl.middleware.debug/with-initial-debug-bindings
([& body])
Macro
  Let-wrap `body` with STATE__ map containing code, file, line, column etc.
  STATE__ is an anaphoric variable available to all breakpoint macros. Ends with
  __ to avid conflicts with user locals and to signify that it's an internal
  variable which is cleaned in `sanitize-env' along other clojure's
  temporaries.
-------------------------
clojure.core.server/parse-props
([props])
  Parse clojure.server.* from properties to produce a map of server configs.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.meta/maybe-add-file
([{:keys [file ns], :as meta-map}])
  If `meta-map` has no :file, assoc the canonical namespace source file.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.meta/maybe-add-see-also
([v meta-map])
  If the var `v` has a see-also has associated with it, assoc that into meta-map.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.meta/maybe-add-spec
([v meta-map])
  If the var `v` has a spec has associated with it, assoc that into meta-map.
  The spec is formatted to avoid processing in the client (e.g. CIDER).
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.meta/merge-meta
([obj & metamaps])
  Non-throwing version of (vary-meta obj merge metamap-1 metamap-2 ...).
  Like `vary-meta`, this only applies to immutable objects. For
  instance, this function does nothing on atoms, because the metadata
  of an `atom` is part of the atom itself and can only be changed
  destructively.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.meta/var-code
([v])
  Find the source of the var `v`.
  Return a map of the var's metadata (:file, :line, :column, etc.) as well as:
    - :form : The form, as read by `clojure.core/read`, and
    - :code : The source code of the form
  Return nil if the source of the var cannot be found.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.meta/var-meta
([v] [v whitelist])
  Return a map of metadata for var v.
  If whitelist is missing use var-meta-whitelist.
-------------------------
nrepl.server/map->Server
([m__7873__auto__])
  Factory function for class nrepl.server.Server, taking a map of keywords to field values.
-------------------------
nrepl.server/start-server
([& {:keys [port bind socket transport-fn handler ack-port greeting-fn]}])
  Starts a socket-based nREPL server.  Configuration options include:

   * :port — defaults to 0, which autoselects an open port
   * :bind — bind address, by default "127.0.0.1"
   * :socket — filesystem socket path (alternative to :port and :bind).
       Note that POSIX does not specify the effect (if any) of the
       socket file's permissions (and some systems have ignored them),
       so any access control should be arranged via parent directories.
   * :handler — the nREPL message handler to use for each incoming connection;
       defaults to the result of `(default-handler)`
   * :transport-fn — a function that, given a java.net.Socket corresponding
       to an incoming connection, will return a value satisfying the
       nrepl.Transport protocol for that Socket.
   * :ack-port — if specified, the port of an already-running server
       that will be connected to inform of the new server's port.
       Useful only by Clojure tooling implementations.
   * :greeting-fn - called after a client conn
ects, receives
       a nrepl.transport/Transport. Usually, Clojure-aware client-side tooling
       would provide this greeting upon connecting to the server, but telnet et
       al. isn't that. See `nrepl.transport/tty-greeting` for an example of such
       a function.

   Returns a (record) handle to the server that is started, which may be stopped
   either via `stop-server`, (.close server), or automatically via `with-open`.
   The port that the server is open on is available in the :port slot of the
   server map (useful if the :port option is 0 or was left unspecified.
-------------------------
nrepl.middleware.session/create-session
([{:keys [transport session out-limit]}])
  Returns a new atom containing a map of bindings as per
  `clojure.core/get-thread-bindings`. *in* is obtained using `session-in`, *ns*
  defaults to 'user, and other bindings as optionally provided in
  `session` are merged in.
-------------------------
nrepl.middleware.session/session-exec
([id])
  Takes a session id and returns a maps of three functions meant for interruptible-eval:
   * :exec, takes an id (typically a msg-id), a thunk and an ack runnables (see #'default-exec for ampler
     context). Executions are serialized and occurs on a single thread.
   * :interrupt, takes an id and tries to interrupt the matching execution (submitted with :exec above).
     A nil id is meant to match the currently running execution. The return value can be either:
     :idle (no running execution), the interrupted id, or nil when the running id doesn't match the id argument.
     Upon successful interruption the backing thread is replaced.
   * :close, terminates the backing thread.
-------------------------
clojure.reflect/declared-constructors
([cls])
  Return a set of the declared constructors of class as a Clojure map.
-------------------------
clojure.reflect/declared-fields
([cls])
  Return a set of the declared fields of class as a Clojure map.
-------------------------
clojure.reflect/declared-methods
([cls])
  Return a set of the declared constructors of class as a Clojure map.
-------------------------
clojure.reflect/map->Constructor
([m__7873__auto__])
  Factory function for class clojure.reflect.Constructor, taking a map of keywords to field values.
-------------------------
clojure.reflect/map->Field
([m__7873__auto__])
  Factory function for class clojure.reflect.Field, taking a map of keywords to field values.
-------------------------
clojure.reflect/map->Method
([m__7873__auto__])
  Factory function for class clojure.reflect.Method, taking a map of keywords to field values.
-------------------------
clojure.reflect/type-reflect
([typeref & options])
  Alpha - subject to change.
   Reflect on a typeref, returning a map with :bases, :flags, and
  :members. In the discussion below, names are always Clojure symbols.

   :bases            a set of names of the type's bases
   :flags            a set of keywords naming the boolean attributes
                     of the type.
   :members          a set of the type's members. Each member is a map
                     and can be a constructor, method, or field.

   Keys common to all members:
   :name             name of the type 
   :declaring-class  name of the declarer
   :flags            keyword naming boolean attributes of the member

   Keys specific to constructors:
   :parameter-types  vector of parameter type names
   :exception-types  vector of exception type names

   Key specific to methods:
   :parameter-types  vector of parameter type names
   :exception-types  vector of exception type names
   :return-type      return type name

   Keys specific to fields:
   :type             type name

   Option
s:

     :ancestors     in addition to the keys described above, also
                    include an :ancestors key with the entire set of
                    ancestors, and add all ancestor members to
                    :members.
     :reflector     implementation to use. Defaults to JavaReflector,
                    AsmReflector is also an option.
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v6.clojure.tools.reader.default-data-readers/read-instant-calendar
  To read an instant as a java.util.Calendar, bind *data-readers* to a map with
this var as the value for the 'inst key.  Calendar preserves the timezone
offset.
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v6.clojure.tools.reader.default-data-readers/read-instant-date
  To read an instant as a java.util.Date, bind *data-readers* to a map with
this var as the value for the 'inst key. The timezone offset will be used
to convert into UTC.
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v6.clojure.tools.reader.default-data-readers/read-instant-timestamp
  To read an instant as a java.sql.Timestamp, bind *data-readers* to a
map with this var as the value for the 'inst key. Timestamp preserves
fractional seconds with nanosecond precision. The timezone offset will
be used to convert into UTC.
-------------------------
cider.nrepl.middleware.util.error-handling/error-summary
([ex & statuses])
  Takes a `java.lang.Exception` as `ex` and returns a map summarizing
  the exception. If present, the varargs are converted to a set and
  used as the value for the :status key.
-------------------------
cider.nrepl.middleware.util.error-handling/selector
([input & _])
  Selector used for dispatch on both the `op` and `error` handler
  multimethods. The handlers expect one of the following:

  - map => A map that will form the basis of the nREPL reply
    message.
  - fn (NOT ifn's) => A fn with arity 1 for ops and 2 for errors, must
    return a map that will form the basis of the nREPL reply message.
  - coll => The coll will be turned into a set which is used as the
    reply message's status.
  - kw => Wrapped in a set and used as the reply message's status.
  - ::default => used as the default error handler, which simply adds
    a reasonably named keyword (ie, `:<op>-error`) to the status.
-------------------------
cider.nrepl.middleware.util.error-handling/with-safe-transport
([handler msg & pairings])
Macro
  This will safely handle all the transport calls mapped out in the
  `handle-<middleware>` functions. All checked exceptions will be caught,
  analyzed by the `cider.nrepl.middleware.stacktrace` middleware, and an error
  message will be returned to the client with a stacktrace renderable by the
  default CIDER stacktrace viewer. Takes the default pass-through `handler`
  current `msg` and a list of pairings between op names and actions used to
  process the ops as varargs. Actions can either be expressed as a 2-item vector
  with the head being the op-action and the tail being the error-action, or if
  the default error handler is sufficient, then the op name can be paired
  directly to the op-action.

  Actions can be functions, maps, non-associate collections, and single items
  such as kw's, strings, numbers, etc. The utilization of each type is discussed
  above in the `selector` method.
-------------------------
clojure.spec.alpha/alt
([& key-pred-forms])
Macro
  Takes key+pred pairs, e.g.

  (s/alt :even even? :small #(< % 42))

  Returns a regex op that returns a map entry containing the key of the
  first matching pred and the corresponding value. Thus the
  'key' and 'val' functions can be used to refer generically to the
  components of the tagged return
-------------------------
clojure.spec.alpha/cat
([& key-pred-forms])
Macro
  Takes key+pred pairs, e.g.

  (s/cat :e even? :o odd?)

  Returns a regex op that matches (all) values in sequence, returning a map
  containing the keys of each pred and the corresponding value.
-------------------------
clojure.spec.alpha/coll-of
([pred & opts])
Macro
  Returns a spec for a collection of items satisfying pred. Unlike
  'every', coll-of will exhaustively conform every value.

  Same options as 'every'. conform will produce a collection
  corresponding to :into if supplied, else will match the input collection,
  avoiding rebuilding when possible.

  See also - every, map-of
-------------------------
clojure.spec.alpha/def
([k spec-form])
Macro
  Given a namespace-qualified keyword or resolvable symbol k, and a
  spec, spec-name, predicate or regex-op makes an entry in the
  registry mapping k to the spec. Use nil to remove an entry in
  the registry for k.
-------------------------
clojure.spec.alpha/every-impl
([form pred opts] [form pred {conform-into :into, describe-form :clojure.spec.alpha/describe, :keys [kind :clojure.spec.alpha/kind-form count max-count min-count distinct gen-max :clojure.spec.alpha/kfn :clojure.spec.alpha/cpred conform-keys :clojure.spec.alpha/conform-all], :or {gen-max 20}, :as opts} gfn])
  Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'
-------------------------
clojure.spec.alpha/every-kv
([kpred vpred & opts])
Macro
  like 'every' but takes separate key and val preds and works on associative collections.

  Same options as 'every', :into defaults to {}

  See also - map-of
-------------------------
clojure.spec.alpha/exercise
([spec] [spec n] [spec n overrides])
  generates a number (default 10) of values compatible with spec and maps conform over them,
  returning a sequence of [val conformed-val] tuples. Optionally takes
  a generator overrides map as per gen
-------------------------
clojure.spec.alpha/explain-data
([spec x])
  Given a spec and a value x which ought to conform, returns nil if x
  conforms, else a map with at least the key ::problems whose value is
  a collection of problem-maps, where problem-map has at least :path :pred and :val
  keys describing the predicate and the value that failed at that
  path.
-------------------------
clojure.spec.alpha/gen
([spec] [spec overrides])
  Given a spec, returns the generator for it, or throws if none can
  be constructed. Optionally an overrides map can be provided which
  should map spec names or paths (vectors of keywords) to no-arg
  generator-creating fns. These will be used instead of the generators at those
  names/paths. Note that parent generator (in the spec or overrides
  map) will supersede those of any subtrees. A generator for a regex
  op must always return a sequential collection (i.e. a generator for
  s/? should return either an empty sequence/vector or a
  sequence/vector with one item in it)
-------------------------
clojure.spec.alpha/keys
([& {:keys [req req-un opt opt-un gen]}])
Macro
  Creates and returns a map validating spec. :req and :opt are both
  vectors of namespaced-qualified keywords. The validator will ensure
  the :req keys are present. The :opt keys serve as documentation and
  may be used by the generator.

  The :req key vector supports 'and' and 'or' for key groups:

  (s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])

  There are also -un versions of :req and :opt. These allow
  you to connect unqualified keys to specs.  In each case, fully
  qualfied keywords are passed, which name the specs, but unqualified
  keys (with the same name component) are expected and checked at
  conform-time, and generated during gen:

  (s/keys :req-un [:my.ns/x :my.ns/y])

  The above says keys :x and :y are required, and will be validated
  and generated by specs (if they exist) named :my.ns/x :my.ns/y 
  respectively.

  In addition, the values of *all* namespace-qualified keys will be validated
  (and possibly destructured) by any registered specs. Note: there is
  no s
upport for inline value specification, by design.

  Optionally takes :gen generator-fn, which must be a fn of no args that
  returns a test.check generator.
-------------------------
clojure.spec.alpha/keys*
([& kspecs])
Macro
  takes the same arguments as spec/keys and returns a regex op that matches sequences of key/values,
  converts them into a map, and conforms that map with a corresponding
  spec/keys call:

  user=> (s/conform (s/keys :req-un [::a ::c]) {:a 1 :c 2})
  {:a 1, :c 2}
  user=> (s/conform (s/keys* :req-un [::a ::c]) [:a 1 :c 2])
  {:a 1, :c 2}

  the resulting regex op can be composed into a larger regex:

  user=> (s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])
  {:i1 42, :m {:a 1, :c 2, :d 4}, :i2 99}
-------------------------
clojure.spec.alpha/map-of
([kpred vpred & opts])
Macro
  Returns a spec for a map whose keys satisfy kpred and vals satisfy
  vpred. Unlike 'every-kv', map-of will exhaustively conform every
  value.

  Same options as 'every', :kind defaults to map?, with the addition of:

  :conform-keys - conform keys as well as values (default false)

  See also - every-kv
-------------------------
clojure.spec.alpha/map-spec-impl
([{:keys [req-un opt-un keys-pred pred-exprs opt-keys req-specs req req-keys opt-specs pred-forms opt gfn], :as argm}])
  Do not call this directly, use 'spec' with a map argument
-------------------------
clojure.spec.alpha/merge
([& pred-forms])
Macro
  Takes map-validating specs (e.g. 'keys' specs) and
  returns a spec that returns a conformed map satisfying all of the
  specs.  Unlike 'and', merge can generate maps satisfying the
  union of the predicates.
-------------------------
clojure.spec.alpha/or
([& key-pred-forms])
Macro
  Takes key+pred pairs, e.g.

  (s/or :even even? :small #(< % 42))

  Returns a destructuring spec that returns a map entry containing the
  key of the first matching pred and the corresponding value. Thus the
  'key' and 'val' functions can be used to refer generically to the
  components of the tagged return.
-------------------------
clojure.spec.alpha/registry
([])
  returns the registry map, prefer 'get-spec' to lookup a spec by name
-------------------------
nrepl.util.completion/completions
([prefix] [prefix ns] [prefix ns options])
  Return a sequence of matching completion candidates given a prefix string and an optional current namespace.
  You can also provide an additional `options` map to tweak the candidate list to your needs.
  E.g. you can pass {:extra-metadata #{:arglists :doc}} to request additional metadata for the candidates.
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.dependency/map->MapDependencyGraph
([m__7873__auto__])
  Factory function for class cider.nrepl.inlined_deps.toolsnamespace.v1v0v0.clojure.tools.namespace.dependency.MapDependencyGraph, taking a map of keywords to field values.
-------------------------
clojure.set/index
([xrel ks])
  Returns a map of the distinct values of ks in the xrel mapped to a
  set of the maps in xrel with the corresponding values of ks.
-------------------------
clojure.set/join
([xrel yrel] [xrel yrel km])
  When passed 2 rels, returns the rel corresponding to the natural
  join. When passed an additional keymap, joins on the corresponding
  keys.
-------------------------
clojure.set/map-invert
([m])
  Returns the map with the vals mapped to the keys.
-------------------------
clojure.set/rename
([xrel kmap])
  Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap
-------------------------
clojure.set/rename-keys
([map kmap])
  Returns the map with the keys in kmap renamed to the vals in kmap
-------------------------
cider.nrepl.middleware.stacktrace/analyze-cause
([e print-fn])
  Return a map describing the exception cause. If `ex-data` exists, a `:data`
  key is appended.
-------------------------
cider.nrepl.middleware.stacktrace/analyze-causes
([e print-fn])
  Return the cause chain beginning with the thrown exception, with stack frames
  for each. For `ex-info` exceptions response contains :data slot with pretty
  printed data. For clojure.spec asserts, :spec slot contains a map of pretty
  printed components describing spec failures.
-------------------------
cider.nrepl.middleware.stacktrace/analyze-file
([{:keys [file], :as frame}])
  Associate the file type (extension) of the source file to the frame map, and
  add it as a flag. If the name is `NO_SOURCE_FILE`, type `clj` is assumed.
-------------------------
cider.nrepl.middleware.stacktrace/analyze-fn
([{:keys [type class method], :as frame}])
  Add namespace, fn, and var to the frame map when the source is a Clojure
  function.
-------------------------
cider.nrepl.middleware.stacktrace/analyze-frame
([namespaces frame])
  Return the stacktrace as a sequence of maps, each describing a stack frame.
-------------------------
cider.nrepl.middleware.stacktrace/analyze-stacktrace
([e])
  Return the stacktrace as a sequence of maps, each describing a stack frame.
-------------------------
cider.nrepl.middleware.stacktrace/prepare-spec-data
([ed pprint-str])
  Prepare spec problems for display in user stacktraces.
  Take in a map `ed` as returned by `clojure.spec/explain-data` and return a map
  of pretty printed problems. The content of the returned map is modeled after
  `clojure.spec/explain-printer`.
-------------------------
cider.nrepl.middleware.stacktrace/stack-frame
([frame])
  Return a map describing the stack frame.
-------------------------
clojure.string/escape
([s cmap])
  Return a new string, using cmap to escape each character ch
   from s as follows:
   
   If (cmap ch) is nil, append ch to the new string.
   If (cmap ch) is non-nil, append (str (cmap ch)) instead.
-------------------------
cider.nrepl.inlined-deps.compliment.v0v3v12.compliment.utils/classes-on-classpath
([])
  Returns a map of all classes that can be located on the classpath. Key
  represent the root package of the class, and value is a list of all classes
  for that package.
-------------------------
cider.nrepl.inlined-deps.suitable.v0v4v1.suitable.complete-for-nrepl/cljs-eval
([session ns code])
  Grabs the necessary compiler and repl envs from the message and uses the plain
  cljs.repl interface for evaluation. Returns a map with :value and :error. Note
  that :value will be a still stringified edn value.
-------------------------
cider.nrepl.inlined-deps.compliment.v0v3v12.compliment.core/completions
([prefix] [prefix options-map])
  Returns a list of completions for the given prefix.

  Options map can contain the following options:
   - :ns - namespace where completion is initiated;
   - :context - code form around the prefix;
   - :sort-order (either :by-length or :by-name);
   - :plain-candidates - if true, returns plain strings instead of maps;
   - :extra-metadata - set of extra fields to add to the maps;
   - :sources - list of source keywords to use.
-------------------------
cider.nrepl.inlined-deps.compliment.v0v3v12.compliment.core/documentation
([symbol-str] [symbol-str ns] [symbol-str ns options-map])
  Returns a documentation string that describes the given symbol.

  Options map can contain the following options:
   - :sources - list of source keywords to use.
-------------------------
cider.nrepl.inlined-deps.compliment.v0v3v12.compliment.sources.local-bindings/parse-binding
([binding-node])
  Given a binding node returns the list of local bindings introduced by that
  node. Handles vector and map destructuring.
-------------------------
nrepl.misc/response-for
([{:keys [session id]} & response-data])
  Returns a map containing the :session and :id from the "request" `msg`
   as well as all entries specified in `response-data`, which can be one
   or more maps (which will be merged), *or* key-value pairs.

   (response-for msg :status :done :value "5")
   (response-for msg {:status :interrupted})

   The :session value in `msg` may be any Clojure reference type (to accommodate
   likely implementations of sessions) that has an :id slot in its metadata,
   or a string.
-------------------------
nrepl.misc/sanitize-meta
([m])
  Sanitize a Clojure metadata map such that it can be bencoded.
-------------------------
clojure.core/*clojure-version*
  The version info for Clojure core, as a map containing :major :minor 
  :incremental and :qualifier keys. Feature releases may increment 
  :minor and/or :major, bugfix releases will increment :incremental. 
  Possible values of :qualifier include "GA", "SNAPSHOT", "RC-x" "BETA-x"
-------------------------
clojure.core/*compiler-options*
  A map of keys to options.
  Note, when binding dynamically make sure to merge with previous value.
  Supported options:
  :elide-meta - a collection of metadata keys to elide during compilation.
  :disable-locals-clearing - set to true to disable clearing, useful for using a debugger
  Alpha, subject to change.
-------------------------
clojure.core/*data-readers*
  Map from reader tag symbols to data reader Vars.

  When Clojure starts, it searches for files named 'data_readers.clj'
  and 'data_readers.cljc' at the root of the classpath. Each such file
  must contain a literal map of symbols, like this:

      {foo/bar my.project.foo/bar
       foo/baz my.project/baz}

  The first symbol in each pair is a tag that will be recognized by
  the Clojure reader. The second symbol in the pair is the
  fully-qualified name of a Var which will be invoked by the reader to
  parse the form following the tag. For example, given the
  data_readers.clj file above, the Clojure reader would parse this
  form:

      #foo/bar [1 2 3]

  by invoking the Var #'my.project.foo/bar on the vector [1 2 3]. The
  data reader function is invoked on the form AFTER it has been read
  as a normal Clojure data structure by the reader.

  Reader tags without namespace qualifiers are reserved for
  Clojure. Default reader tags are defined in
  clojure.core/default-data-readers but may be overridden
 in
  data_readers.clj, data_readers.cljc, or by rebinding this Var.
-------------------------
clojure.core/*print-namespace-maps*
  *print-namespace-maps* controls whether the printer will print
  namespace map literal syntax. It defaults to false, but the REPL binds
  to true.
-------------------------
clojure.core/Throwable->map
([o])
  Constructs a data representation for a Throwable with keys:
    :cause - root cause message
    :phase - error phase
    :via - cause chain, with cause keys:
             :type - exception class symbol
             :message - exception message
             :data - ex-data
             :at - top stack element
    :trace - root cause stack elements
-------------------------
clojure.core/accessor
([s key])
  Returns a fn that, given an instance of a structmap with the basis,
  returns the value at the key.  The key must be in the basis. The
  returned function should be (slightly) more efficient than using
  get, but such use of accessors should be limited to known
  performance-critical areas.
-------------------------
clojure.core/agent
([state & options])
  Creates and returns an agent with an initial value of state and
  zero or more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :error-handler handler-fn

  :error-mode mode-keyword

  If metadata-map is supplied, it will become the metadata on the
  agent. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.  handler-fn is called if an
  action throws an exception or if validate-fn rejects a new state --
  see set-error-handler! for details.  The mode-keyword may be either
  :continue (the default if an error-handler is given) or :fail (the
  default if no error-handler is given) -- see set-error-mode! for
  details.
-------------------------
clojure.core/amap
([a idx ret expr])
Macro
  Maps an expression across an array a, using an index named idx, and
  return value named ret, initialized to a clone of a, then setting 
  each element of ret to the evaluation of expr, returning the new 
  array ret.
-------------------------
clojure.core/array-map
([] [& keyvals])
  Constructs an array-map. If any keys are equal, they are handled as
  if by repeated uses of assoc.
-------------------------
clojure.core/assoc
([map key val] [map key val & kvs])
  assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be <= (count vector).
-------------------------
clojure.core/assoc!
([coll key val] [coll key val & kvs])
  When applied to a transient map, adds mapping of key(s) to
  val(s). When applied to a transient vector, sets the val at index.
  Note - index must be <= (count vector). Returns coll.
-------------------------
clojure.core/assoc-in
([m [k & ks] v])
  Associates a value in a nested associative structure, where ks is a
  sequence of keys and v is the new value and returns a new nested structure.
  If any levels do not exist, hash-maps will be created.
-------------------------
clojure.core/atom
([x] [x & options])
  Creates and returns an Atom with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  If metadata-map is supplied, it will become the metadata on the
  atom. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception.
-------------------------
clojure.core/bean
([x])
  Takes a Java object and returns a read-only implementation of the
  map abstraction based upon its JavaBean properties.
-------------------------
clojure.core/case
([e & clauses])
Macro
  Takes an expression, and a set of clauses.

  Each clause can take the form of either:

  test-constant result-expr

  (test-constant1 ... test-constantN)  result-expr

  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.

  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same t
ype.
-------------------------
clojure.core/case-map
([case-f test-f tests thens])
  Transforms a sequence of test constants and a corresponding sequence of then
  expressions into a sorted map to be consumed by case*. The form of the map
  entries are {(case-f test) [(test-f test) then]}.
-------------------------
clojure.core/check-valid-options
([options & valid-keys])
  Throws an exception if the given option map contains keys not listed
  as valid, else returns nil.
-------------------------
clojure.core/default-data-readers
  Default map of data reader functions provided by Clojure. May be
  overridden by binding *data-readers*.
-------------------------
clojure.core/defmulti
([name docstring? attr-map? dispatch-fn & options])
Macro
  Creates a new multimethod with the associated dispatch function.
  The docstring and attr-map are optional.

  Options are key-value pairs and may be one of:

  :default

  The default dispatch value, defaults to :default

  :hierarchy

  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)

  Hierarchies are type-like relationships that do not depend upon type
  inheritance. By default Clojure's multimethods dispatch off of a
  global hierarchy map.  However, a hierarchy relationship can be
  created with the derive function used to augment the root ancestor
  created with make-hierarchy.

  Multimethods expect the value of the hierarchy option to be supplied as
  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #'
  or the var special form).
-------------------------
clojure.core/defn
([name doc-string? attr-map? [params*] prepost-map? body] [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?])
Macro
  Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions.
Spec
  args: (cat :fn-name simple-symbol? :docstring (? string?) :meta (? map?) :fn-tail (alt :arity-1 :clojure.core.specs.alpha/params+body :arity-n (cat :bodies (+ (spec :clojure.core.specs.alpha/params+body)) :attr-map (? map?))))
  ret: any?
-------------------------
clojure.core/defrecord
([name [& fields] & opts+specs])
Macro
  (defrecord name [fields*]  options* specs*)

  Options are expressed as sequential keywords and arguments (in any order).

  Supported options:
  :load-ns - if true, importing the record class will cause the
             namespace in which the record was defined to be loaded.
             Defaults to false.

  Each spec consists of a protocol or interface name followed by zero
  or more method bodies:

  protocol-or-interface-or-Object
  (methodName [args*] body)*

  Dynamically generates compiled bytecode for class with the given
  name, in a package with the same name as the current namespace, the
  given fields, and, optionally, methods for protocols and/or
  interfaces.

  The class will have the (immutable) fields named by
  fields, which can have type hints. Protocols/interfaces and methods
  are optional. The only methods that can be supplied are those
  declared in the protocols/interfaces.  Note that method bodies are
  not closures, the local environment includes only the named fields,
  and those
 fields can be accessed directly.

  Method definitions take the form:

  (methodname [args*] body)

  The argument and return types can be hinted on the arg and
  methodname symbols. If not supplied, they will be inferred, so type
  hints should be reserved for disambiguation.

  Methods should be supplied for all methods of the desired
  protocol(s) and interface(s). You can also define overrides for
  methods of Object. Note that a parameter must be supplied to
  correspond to the target object ('this' in Java parlance). Thus
  methods for interfaces will take one more argument than do the
  interface declarations. Note also that recur calls to the method
  head should *not* pass the target object, it will be supplied
  automatically and can not be substituted.

  In the method bodies, the (unqualified) name can be used to name the
  class (for calls to new, instance? etc).

  The class will have implementations of several (clojure.lang)
  interfaces generated automatically: IObj (metadata support) and
  I
PersistentMap, and all of their superinterfaces.

  In addition, defrecord will define type-and-value-based =,
  and will defined Java .hashCode and .equals consistent with the
  contract for java.util.Map.

  When AOT compiling, generates compiled bytecode for a class with the
  given name (a symbol), prepends the current ns as the package, and
  writes the .class file to the *compile-path* directory.

  Two constructors will be defined, one taking the designated fields
  followed by a metadata map (nil for none) and an extension field
  map (nil for none), and one taking only the fields (using nil for
  meta and extension fields). Note that the field names __meta,
  __extmap, __hash and __hasheq are currently reserved and should not
  be used when defining your own records.

  Given (defrecord TypeName ...), two factory functions will be
  defined: ->TypeName, taking positional parameters for the fields,
  and map->TypeName, taking a map of keywords to field values.
-------------------------
clojure.core/deftype
([name [& fields] & opts+specs])
Macro
  (deftype name [fields*]  options* specs*)

  Options are expressed as sequential keywords and arguments (in any order).

  Supported options:
  :load-ns - if true, importing the type class will cause the
             namespace in which the type was defined to be loaded.
             Defaults to false.

  Each spec consists of a protocol or interface name followed by zero
  or more method bodies:

  protocol-or-interface-or-Object
  (methodName [args*] body)*

  Dynamically generates compiled bytecode for class with the given
  name, in a package with the same name as the current namespace, the
  given fields, and, optionally, methods for protocols and/or
  interfaces. 

  The class will have the (by default, immutable) fields named by
  fields, which can have type hints. Protocols/interfaces and methods
  are optional. The only methods that can be supplied are those
  declared in the protocols/interfaces.  Note that method bodies are
  not closures, the local environment includes only the named fields,
  an
d those fields can be accessed directly. Fields can be qualified
  with the metadata :volatile-mutable true or :unsynchronized-mutable
  true, at which point (set! afield aval) will be supported in method
  bodies. Note well that mutable fields are extremely difficult to use
  correctly, and are present only to facilitate the building of higher
  level constructs, such as Clojure's reference types, in Clojure
  itself. They are for experts only - if the semantics and
  implications of :volatile-mutable or :unsynchronized-mutable are not
  immediately apparent to you, you should not be using them.

  Method definitions take the form:

  (methodname [args*] body)

  The argument and return types can be hinted on the arg and
  methodname symbols. If not supplied, they will be inferred, so type
  hints should be reserved for disambiguation.

  Methods should be supplied for all methods of the desired
  protocol(s) and interface(s). You can also define overrides for
  methods of Object. Note that a parameter must 
be supplied to
  correspond to the target object ('this' in Java parlance). Thus
  methods for interfaces will take one more argument than do the
  interface declarations. Note also that recur calls to the method
  head should *not* pass the target object, it will be supplied
  automatically and can not be substituted.

  In the method bodies, the (unqualified) name can be used to name the
  class (for calls to new, instance? etc).

  When AOT compiling, generates compiled bytecode for a class with the
  given name (a symbol), prepends the current ns as the package, and
  writes the .class file to the *compile-path* directory.

  One constructor will be defined, taking the designated fields.  Note
  that the field names __meta, __extmap, __hash and __hasheq are currently
  reserved and should not be used when defining your own types.

  Given (deftype TypeName ...), a factory function called ->TypeName
  will be defined, taking positional parameters for the fields
-------------------------
clojure.core/dissoc
([map] [map key] [map key & ks])
  dissoc[iate]. Returns a new map of the same (hashed/sorted) type,
  that does not contain a mapping for key(s).
-------------------------
clojure.core/dissoc!
([map key] [map key & ks])
  Returns a transient map that doesn't contain a mapping for key(s).
-------------------------
clojure.core/ex-data
([ex])
  Returns exception data (a map) if ex is an IExceptionInfo.
   Otherwise returns nil.
-------------------------
clojure.core/ex-info
([msg map] [msg map cause])
  Create an instance of ExceptionInfo, a RuntimeException subclass
   that carries a map of additional data.
-------------------------
clojure.core/extend
([atype & proto+mmaps])
  Implementations of protocol methods can be provided using the extend construct:

  (extend AType
    AProtocol
     {:foo an-existing-fn
      :bar (fn [a b] ...)
      :baz (fn ([a]...) ([a b] ...)...)}
    BProtocol 
      {...} 
    ...)
 
  extend takes a type/class (or interface, see below), and one or more
  protocol + method map pairs. It will extend the polymorphism of the
  protocol's methods to call the supplied methods when an AType is
  provided as the first argument. 

  Method maps are maps of the keyword-ized method names to ordinary
  fns. This facilitates easy reuse of existing fns and fn maps, for
  code reuse/mixins without derivation or composition. You can extend
  an interface to a protocol. This is primarily to facilitate interop
  with the host (e.g. Java) but opens the door to incidental multiple
  inheritance of implementation since a class can inherit from more
  than one interface, both of which extend the protocol. It is TBD how
  to specify which impl to use. You can extend a p
rotocol on nil.

  If you are supplying the definitions explicitly (i.e. not reusing
  exsting functions or mixin maps), you may find it more convenient to
  use the extend-type or extend-protocol macros.

  Note that multiple independent extend clauses can exist for the same
  type, not all protocols need be defined in a single extend call.

  See also:
  extends?, satisfies?, extenders
-------------------------
clojure.core/extend-type
([t & specs])
Macro
  A macro that expands into an extend call. Useful when you are
  supplying the definitions explicitly inline, extend-type
  automatically creates the maps required by extend.  Propagates the
  class as a type hint on the first argument of all fns.

  (extend-type MyType 
    Countable
      (cnt [c] ...)
    Foo
      (bar [x y] ...)
      (baz ([x] ...) ([x y & zs] ...)))

  expands into:

  (extend MyType
   Countable
     {:cnt (fn [c] ...)}
   Foo
     {:baz (fn ([x] ...) ([x y & zs] ...))
      :bar (fn [x y] ...)})
-------------------------
clojure.core/find
([map key])
  Returns the map entry for key, or nil if key not present.
-------------------------
clojure.core/frequencies
([coll])
  Returns a map from distinct items in coll to the number of times
  they appear.
-------------------------
clojure.core/gen-class
([& options])
Macro
  When compiling, generates compiled bytecode for a class with the
  given package-qualified :name (which, as all names in these
  parameters, can be a string or symbol), and writes the .class file
  to the *compile-path* directory.  When not compiling, does
  nothing. The gen-class construct contains no implementation, as the
  implementation will be dynamically sought by the generated class in
  functions in an implementing Clojure namespace. Given a generated
  class org.mydomain.MyClass with a method named mymethod, gen-class
  will generate an implementation that looks for a function named by 
  (str prefix mymethod) (default prefix: "-") in a
  Clojure namespace specified by :impl-ns
  (defaults to the current namespace). All inherited methods,
  generated methods, and init and main functions (see :methods, :init,
  and :main below) will be found similarly prefixed. By default, the
  static initializer for the generated class will attempt to load the
  Clojure support code for the class as a resource fr
om the classpath,
  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This
  behavior can be controlled by :load-impl-ns

  Note that methods with a maximum of 18 parameters are supported.

  In all subsequent sections taking types, the primitive types can be
  referred to by their Java names (int, float etc), and classes in the
  java.lang package can be used without a package qualifier. All other
  classes must be fully qualified.

  Options should be a set of key/value pairs, all except for :name are optional:

  :name aname

  The package-qualified name of the class to be generated

  :extends aclass

  Specifies the superclass, the non-private methods of which will be
  overridden by the class. If not provided, defaults to Object.

  :implements [interface ...]

  One or more interfaces, the methods of which will be implemented by the class.

  :init name

  If supplied, names a function that will be called with the arguments
  to the constructor. Must return [ [superclass-constructor-args]
 state] 
  If not supplied, the constructor args are passed directly to
  the superclass constructor and the state will be nil

  :constructors {[param-types] [super-param-types], ...}

  By default, constructors are created for the generated class which
  match the signature(s) of the constructors for the superclass. This
  parameter may be used to explicitly specify constructors, each entry
  providing a mapping from a constructor signature to a superclass
  constructor signature. When you supply this, you must supply an :init
  specifier. 

  :post-init name

  If supplied, names a function that will be called with the object as
  the first argument, followed by the arguments to the constructor.
  It will be called every time an object of this class is created,
  immediately after all the inherited constructors have completed.
  Its return value is ignored.

  :methods [ [name [param-types] return-type], ...]

  The generated class automatically defines all of the non-private
  methods of its superclasses/
interfaces. This parameter can be used
  to specify the signatures of additional methods of the generated
  class. Static methods can be specified with ^{:static true} in the
  signature's metadata. Do not repeat superclass/interface signatures
  here.

  :main boolean

  If supplied and true, a static public main function will be generated. It will
  pass each string of the String[] argument as a separate argument to
  a function called (str prefix main).

  :factory name

  If supplied, a (set of) public static factory function(s) will be
  created with the given name, and the same signature(s) as the
  constructor(s).
  
  :state name

  If supplied, a public final instance field with the given name will be
  created. You must supply an :init function in order to provide a
  value for the state. Note that, though final, the state can be a ref
  or agent, supporting the creation of Java objects with transactional
  or asynchronous mutation semantics.

  :exposes {protected-field-name {:get name :set name}, 
...}

  Since the implementations of the methods of the generated class
  occur in Clojure functions, they have no access to the inherited
  protected fields of the superclass. This parameter can be used to
  generate public getter/setter methods exposing the protected field(s)
  for use in the implementation.

  :exposes-methods {super-method-name exposed-name, ...}

  It is sometimes necessary to call the superclass' implementation of an
  overridden method.  Those methods may be exposed and referred in 
  the new method implementation by a local name.

  :prefix string

  Default: "-" Methods called e.g. Foo will be looked up in vars called
  prefixFoo in the implementing ns.

  :impl-ns name

  Default: the name of the current ns. Implementations of methods will be 
  looked up in this namespace.

  :load-impl-ns boolean

  Default: true. Causes the static initializer for the generated class
  to reference the load code for the implementing namespace. Should be
  true when implementing-ns is the default, 
false if you intend to
  load the code via some other method.
-------------------------
clojure.core/get
([map key] [map key not-found])
  Returns the value mapped to key, not-found or nil if key not present.
-------------------------
clojure.core/get-thread-bindings
([])
  Get a map with the Var/value pairs which is currently in effect for the
  current thread.
-------------------------
clojure.core/group-by
([f coll])
  Returns a map of the elements of coll keyed by the result of
  f on each element. The value at each key will be a vector of the
  corresponding elements, in the order they appeared in coll.
-------------------------
clojure.core/group-by-sig
([coll])
  Takes a collection of [msig meth] and returns a seq of maps from
   return-types to meths.
-------------------------
clojure.core/hash-map
([] [& keyvals])
  keyval => key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.
-------------------------
clojure.core/hash-unordered-coll
([coll])
  Returns the hash code, consistent with =, for an external unordered
   collection implementing Iterable. For maps, the iterator should
   return map entries whose hash is computed as
     (hash-ordered-coll [k v]).
   See http://clojure.org/data_structures#hash for full algorithms.
-------------------------
clojure.core/ifn?
([x])
  Returns true if x implements IFn. Note that many data structures
  (e.g. sets and maps) implement IFn
-------------------------
clojure.core/import
([& import-symbols-or-lists])
Macro
  import-list => (package-symbol class-name-symbols*)

  For each name in class-name-symbols, adds a mapping from name to the
  class named by package.name to the current namespace. Use :import in the ns
  macro in preference to calling this directly.
Spec
  args: (* (alt :class (quotable simple-symbol?) :package-list (quotable :clojure.core.specs.alpha/package-list)))
  ret: any?
-------------------------
clojure.core/init-proxy
([proxy mappings])
  Takes a proxy instance and a map of strings (which must
  correspond to methods of the proxy superclass/superinterfaces) to
  fns (which must take arguments matching the corresponding method,
  plus an additional (explicit) first arg corresponding to this, and
  sets the proxy's fn map.  Returns the proxy.
-------------------------
clojure.core/key
([e])
  Returns the key of the map entry.
-------------------------
clojure.core/keys
([map])
  Returns a sequence of the map's keys, in the same order as (seq map).
-------------------------
clojure.core/lift-ns
([m])
  Returns [lifted-ns lifted-map] or nil if m can't be lifted.
-------------------------
clojure.core/map
([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])
  Returns a lazy sequence consisting of the result of applying f to
  the set of first items of each coll, followed by applying f to the
  set of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments. Returns a transducer when
  no collection is provided.
-------------------------
clojure.core/map-entry?
([x])
  Return true if x is a map entry
-------------------------
clojure.core/map-indexed
([f] [f coll])
  Returns a lazy sequence consisting of the result of applying f to 0
  and the first item of coll, followed by applying f to 1 and the second
  item in coll, etc, until coll is exhausted. Thus function f should
  accept 2 arguments, index and item. Returns a stateful transducer when
  no collection is provided.
-------------------------
clojure.core/map?
([x])
  Return true if x implements IPersistentMap
-------------------------
clojure.core/mapcat
([f] [f & colls])
  Returns the result of applying concat to the result of applying map
  to f and colls.  Thus function f should return a collection. Returns
  a transducer when no collections are provided
-------------------------
clojure.core/mapv
([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])
  Returns a vector consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments.
-------------------------
clojure.core/memoize
([f])
  Returns a memoized version of a referentially transparent function. The
  memoized version of the function keeps a cache of the mapping from arguments
  to results and, when calls with the same arguments are repeated often, has
  higher performance at the expense of higher memory use.
-------------------------
clojure.core/merge
([& maps])
  Returns a map that consists of the rest of the maps conj-ed onto
  the first.  If a key occurs in more than one map, the mapping from
  the latter (left-to-right) will be the mapping in the result.
-------------------------
clojure.core/merge-with
([f & maps])
  Returns a map that consists of the rest of the maps conj-ed onto
  the first.  If a key occurs in more than one map, the mapping(s)
  from the latter (left-to-right) will be combined with the mapping in
  the result by calling (f val-in-result val-in-latter).
-------------------------
clojure.core/methods
([multifn])
  Given a multimethod, returns a map of dispatch values -> dispatch fns
-------------------------
clojure.core/ns-aliases
([ns])
  Returns a map of the aliases for the namespace.
-------------------------
clojure.core/ns-imports
([ns])
  Returns a map of the import mappings for the namespace.
-------------------------
clojure.core/ns-interns
([ns])
  Returns a map of the intern mappings for the namespace.
-------------------------
clojure.core/ns-map
([ns])
  Returns a map of all the mappings for the namespace.
-------------------------
clojure.core/ns-publics
([ns])
  Returns a map of the public intern mappings for the namespace.
-------------------------
clojure.core/ns-refers
([ns])
  Returns a map of the refer mappings for the namespace.
-------------------------
clojure.core/ns-unmap
([ns sym])
  Removes the mappings for the symbol from the namespace.
-------------------------
clojure.core/pmap
([f coll] [f coll & colls])
  Like map, except f is applied in parallel. Semi-lazy in that the
  parallel computation stays ahead of the consumption, but doesn't
  realize the entire result unless required. Only useful for
  computationally intensive functions where the time of f dominates
  the coordination overhead.
-------------------------
clojure.core/prefers
([multifn])
  Given a multimethod, returns a map of preferred value -> set of other values
-------------------------
clojure.core/prep-hashes
([expr-sym default tests thens])
  Takes a sequence of test constants and a corresponding sequence of then
  expressions. Returns a tuple of [shift mask case-map switch-type skip-check]
  where case-map is a map of int case values to [test then] tuples, switch-type
  is either :sparse or :compact, and skip-check is a set of case ints for which
  post-switch equivalence checking must not be done (occurs with hash
  collisions).
-------------------------
clojure.core/prep-ints
([tests thens])
  Takes a sequence of int-sized test constants and a corresponding sequence of
  then expressions. Returns a tuple of [shift mask case-map switch-type] where
  case-map is a map of int case values to [test then] tuples, and switch-type
  is either :sparse or :compact.
-------------------------
clojure.core/proxy-mappings
([proxy])
  Takes a proxy instance and returns the proxy's fn map.
-------------------------
clojure.core/push-thread-bindings
([bindings])
  WARNING: This is a low-level function. Prefer high-level macros like
  binding where ever possible.

  Takes a map of Var/value pairs. Binds each Var to the associated value for
  the current thread. Each call *MUST* be accompanied by a matching call to
  pop-thread-bindings wrapped in a try-finally!
  
      (push-thread-bindings bindings)
      (try
        ...
        (finally
          (pop-thread-bindings)))
-------------------------
clojure.core/read
([] [stream] [stream eof-error? eof-value] [stream eof-error? eof-value recursive?] [opts stream])
  Reads the next object from stream, which must be an instance of
  java.io.PushbackReader or some derivee.  stream defaults to the
  current value of *in*.

  Opts is a persistent map with valid keys:
    :read-cond - :allow to process reader conditionals, or
                 :preserve to keep all branches
    :features - persistent set of feature keywords for reader conditionals
    :eof - on eof, return value unless :eofthrow, then throw.
           if not specified, will throw

  Note that read can execute code (controlled by *read-eval*),
  and as such should be used only with trusted sources.

  For data structure interop use clojure.edn/read
-------------------------
clojure.core/ref
([x] [x & options])
  Creates and returns a Ref with an initial value of x and zero or
  more options (in any order):

  :meta metadata-map

  :validator validate-fn

  :min-history (default 0)
  :max-history (default 10)

  If metadata-map is supplied, it will become the metadata on the
  ref. validate-fn must be nil or a side-effect-free fn of one
  argument, which will be passed the intended new state on any state
  change. If the new state is unacceptable, the validate-fn should
  return false or throw an exception. validate-fn will be called on
  transaction commit, when all refs have their final values.

  Normally refs accumulate history dynamically as needed to deal with
  read demands. If you know in advance you will need history you can
  set :min-history to ensure it will be available when first needed (instead
  of after a read fault). History is limited, and the limit can be set
  with :max-history.
-------------------------
clojure.core/refer
([ns-sym & filters])
  refers to all public vars of ns, subject to filters.
  filters can include at most one each of:

  :exclude list-of-symbols
  :only list-of-symbols
  :rename map-of-fromsymbol-tosymbol

  For each public interned var in the namespace named by the symbol,
  adds a mapping from the name of the var to the var to the current
  namespace.  Throws an exception if name is already mapped to
  something else in the current namespace. Filters can be used to
  select a subset, via inclusion or exclusion, or to provide a mapping
  to a symbol different from the var's name, in order to prevent
  clashes. Use :use in the ns macro in preference to calling this directly.
-------------------------
clojure.core/replace
([smap] [smap coll])
  Given a map of replacement pairs and a vector/collection, returns a
  vector/seq with any elements = a key in smap replaced with the
  corresponding val in smap.  Returns a transducer when no collection
  is provided.
-------------------------
clojure.core/require
([& args])
  Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.

  Libs

  A 'lib' is a named set of resources in classpath whose contents define a
  library of Clojure code. Lib names are symbols and each lib is associated
  with a Clojure namespace and a Java package that share its name. A lib's
  name also locates its root directory within classpath using Java's
  package name to classpath-relative path mapping. All resources in a lib
  should be contained in the directory structure under its root directory.
  All definitions a lib makes should be in its associated namespace.

  'require loads a lib by loading its root resource. The root resource path
  is derived from the lib name in the following manner:
  Consider a lib named by the symbol 'x.
y.z; it has the root directory
  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj, or
  <classpath>/x/y/z.cljc if <classpath>/x/y/z.clj does not exist. The
  root resource should contain code to create the lib's
  namespace (usually by using the ns macro) and load any additional
  lib resources.

  Libspecs

  A libspec is a lib name or a vector containing a lib name followed by
  options expressed as sequential keywords and arguments.

  Recognized options:
  :as takes a symbol as its argument and makes that symbol an alias to the
    lib's namespace in the current namespace.
  :refer takes a list of symbols to refer from the namespace or the :all
    keyword to bring in all public vars.

  Prefix Lists

  It's common for Clojure code to depend on several libs whose names have
  the same prefix. When specifying libs, prefix lists can be used to reduce
  repetition. A prefix list contains the shared prefix followed by libspecs
  with the shared prefix removed from the lib names. After removing
 the
  prefix, the names that remain must not contain any periods.

  Flags

  A flag is a keyword.
  Recognized flags: :reload, :reload-all, :verbose
  :reload forces loading of all the identified libs even if they are
    already loaded
  :reload-all implies :reload and also forces loading of all libs that the
    identified libs directly or indirectly load via require or use
  :verbose triggers printing information about each load, alias, and refer

  Example:

  The following would load the libraries clojure.zip and clojure.set
  abbreviated as 's'.

  (require '(clojure zip [set :as s]))
-------------------------
clojure.core/resultset-seq
([rs])
  Creates and returns a lazy sequence of structmaps corresponding to
  the rows in the java.sql.ResultSet rs
-------------------------
clojure.core/rseq
([rev])
  Returns, in constant time, a seq of the items in rev (which
  can be a vector or sorted-map), in reverse order. If rev is empty returns nil
-------------------------
clojure.core/select-keys
([map keyseq])
  Returns a map containing only those entries in map whose key is in keys
-------------------------
clojure.core/sorted-map
([& keyvals])
  keyval => key val
  Returns a new sorted map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.
-------------------------
clojure.core/sorted-map-by
([comparator & keyvals])
  keyval => key val
  Returns a new sorted map with supplied mappings, using the supplied
  comparator.  If any keys are equal, they are handled as if by
  repeated uses of assoc.
-------------------------
clojure.core/struct
([s & vals])
  Returns a new structmap instance with the keys of the
  structure-basis. vals must be supplied for basis keys in order -
  where values are not supplied they will default to nil.
-------------------------
clojure.core/struct-map
([s & inits])
  Returns a new structmap instance with the keys of the
  structure-basis. keyvals may contain all, some or none of the basis
  keys - where values are not supplied they will default to nil.
  keyvals can also contain keys not in the basis.
-------------------------
clojure.core/update-in
([m ks f & args])
  'Updates' a value in a nested associative structure, where ks is a
  sequence of keys and f is a function that will take the old value
  and any supplied args and return the new value, and returns a new
  nested structure.  If any levels do not exist, hash-maps will be
  created.
-------------------------
clojure.core/update-proxy
([proxy mappings])
  Takes a proxy instance and a map of strings (which must
  correspond to methods of the proxy superclass/superinterfaces) to
  fns (which must take arguments matching the corresponding method,
  plus an additional (explicit) first arg corresponding to this, and
  updates (via assoc) the proxy's fn map. nil can be passed instead of
  a fn, in which case the corresponding method will revert to the
  default behavior. Note that this function can be used to update the
  behavior of an existing instance without changing its identity.
  Returns the proxy.
-------------------------
clojure.core/val
([e])
  Returns the value in the map entry.
-------------------------
clojure.core/vals
([map])
  Returns a sequence of the map's values, in the same order as (seq map).
-------------------------
clojure.core/with-bindings
([binding-map & body])
Macro
  Takes a map of Var/value pairs. Installs for the given Vars the associated
  values as thread-local bindings. Then executes body. Pops the installed
  bindings after body was evaluated. Returns the value of body.
-------------------------
clojure.core/with-bindings*
([binding-map f & args])
  Takes a map of Var/value pairs. Installs for the given Vars the associated
  values as thread-local bindings. Then calls f with the supplied arguments.
  Pops the installed bindings after f returned. Returns whatever f returns.
-------------------------
clojure.core/with-meta
([obj m])
  Returns an object of the same type and value as obj, with
    map m as its metadata.
-------------------------
clojure.core/with-redefs-fn
([binding-map func])
  Temporarily redefines Vars during a call to func.  Each val of
  binding-map will replace the root value of its key which must be
  a Var.  After func is called with no args, the root values of all
  the Vars will be set back to their old values.  These temporary
  changes will be visible in all threads.  Useful for mocking out
  functions during testing.
-------------------------
clojure.core/zipmap
([keys vals])
  Returns a map with the keys mapped to the corresponding vals.
-------------------------
clojure.walk/keywordize-keys
([m])
  Recursively transforms all map keys from strings to keywords.
-------------------------
clojure.walk/postwalk-replace
([smap form])
  Recursively transforms form by replacing keys in smap with their
  values.  Like clojure/replace but works on any data structure.  Does
  replacement at the leaves of the tree first.
-------------------------
clojure.walk/prewalk-replace
([smap form])
  Recursively transforms form by replacing keys in smap with their
  values.  Like clojure/replace but works on any data structure.  Does
  replacement at the root of the tree first.
-------------------------
clojure.walk/stringify-keys
([m])
  Recursively transforms all map keys from keywords to strings.
-------------------------
nrepl.middleware/set-descriptor!
([middleware-var descriptor])
  Sets the given [descriptor] map as the ::descriptor metadata on
   the provided [middleware-var], after assoc'ing in the var's
   fully-qualified name as the descriptor's "implemented-by" value.
-------------------------
clojure.spec.gen.alpha/fmap
([& args])
  Lazy loaded version of clojure.test.check.generators/fmap
-------------------------
clojure.spec.gen.alpha/hash-map
([& args])
  Lazy loaded version of clojure.test.check.generators/hash-map
-------------------------
clojure.spec.gen.alpha/map
([& args])
  Lazy loaded version of clojure.test.check.generators/map
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.misc/deep-merge
([& xs])
  Merge maps recursively. When vals are not maps, last value wins.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.misc/update-keys
([f m])
  Update the keys of map `m` via the function `f`.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.misc/update-vals
([f m])
  Update the values of map `m` via the function `f`.
-------------------------
cider.nrepl.inlined-deps.compliment.v0v3v12.compliment.sources/defsource
([name & {:as kw-args}])
  Defines a source with the given name and argument map. Map must
  contain two keys - `:candidates` and `:doc`.

  Value of `:candidates`should be a function of prefix, namespace and
  context.

  Value of `:doc` latter should be a function of symbol name and
  namespace.
-------------------------
clojure.main/ex-triage
([datafied-throwable])
  Returns an analysis of the phase, error, cause, and location of an error that occurred
  based on Throwable data, as returned by Throwable->map. All attributes other than phase
  are optional:
    :clojure.error/phase - keyword phase indicator, one of:
      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion
      :execution :read-eval-result :print-eval-result
    :clojure.error/source - file name (no path)
    :clojure.error/line - integer line number
    :clojure.error/column - integer column number
    :clojure.error/symbol - symbol being expanded/compiled/invoked
    :clojure.error/class - cause exception class symbol
    :clojure.error/cause - cause exception message
    :clojure.error/spec - explain-data for spec error
-------------------------
cider.nrepl.middleware.util.cljs/cljs-env-path
([])
  Returns the path in the session map for the ClojureScript compiler
  environment used by piggieback.
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v6.clojure.tools.reader/*alias-map*
  Map from ns alias to ns, if non-nil, it will be used to resolve read-time
   ns aliases instead of (ns-aliases *ns*).

   Defaults to nil
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v6.clojure.tools.reader/default-data-readers
  Default map of data reader functions provided by Clojure.
   May be overridden by binding *data-readers*
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v6.clojure.tools.reader/flatten-map
([form])
  Flatten a map into a seq of alternate keys and values
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v6.clojure.tools.reader/map-func
([coll])
  Decide which map type to use, array-map if less than 16 elements
-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v6.clojure.tools.reader/read
([] [reader] [opts reader] [reader eof-error? eof-value])
  Reads the first object from an IPushbackReader or a java.io.PushbackReader.
   Returns the object read. If EOF, throws if eof-error? is true.
   Otherwise returns sentinel. If no stream is provided, *in* will be used.

   Opts is a persistent map with valid keys:
    :read-cond - :allow to process reader conditionals, or
                 :preserve to keep all branches
    :features - persistent set of feature keywords for reader conditionals
    :eof - on eof, return value unless :eofthrow, then throw.
           if not specified, will throw

   ***WARNING***
   Note that read can execute code (controlled by *read-eval*),
   and as such should be used only with trusted sources.

   To read data structures only, use cider.nrepl.inlined-deps.toolsreader.v1v3v6.clojure.tools.reader.edn/read

   Note that the function signature of cider.nrepl.inlined-deps.toolsreader.v1v3v6.clojure.tools.reader/read and
   cider.nrepl.inlined-deps.toolsreader.v1v3v6.clojure.tools.reader.edn/read is not the same for eof-handling

-------------------------
cider.nrepl.inlined-deps.toolsreader.v1v3v6.clojure.tools.reader/read-map
([rdr _ opts pending-forms])
  Read in a map, including its location if the reader is an indexing reader
-------------------------
clojure.edn/read
([] [stream] [opts stream])
  Reads the next object from stream, which must be an instance of
  java.io.PushbackReader or some derivee.  stream defaults to the
  current value of *in*.

  Reads data in the edn format (subset of Clojure data):
  http://edn-format.org

  opts is a map that can include the following keys:
  :eof - value to return on end-of-file. When not supplied, eof throws an exception.
  :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.
              When not supplied, only the default-data-readers will be used.
  :default - A function of two args, that will, if present and no reader is found for a tag,
             be called with the tag and the value.
-------------------------
clojure.edn/read-string
([s] [opts s])
  Reads one object from the string s. Returns nil when s is nil or empty.

  Reads data in the edn format (subset of Clojure data):
  http://edn-format.org

  opts is a map as per clojure.edn/read
-------------------------
nrepl.socket/map->BufferedOutputChannel
([m__7873__auto__])
  Factory function for class nrepl.socket.BufferedOutputChannel, taking a map of keywords to field values.
-------------------------
nrepl.socket/unix-server-socket
([path])
  Returns a filesystem socket bound to the path if the JDK is version
  16 or newer or if com.kohlschutter.junixsocket/junixsocket-core can
  be loaded dynamically.  Otherwise throws the ex-info map
  {:nrepl/kind ::no-filesystem-sockets}.
-------------------------
cider.nrepl.inlined-deps.compliment.v0v3v12.compliment.sources.namespaces-and-classes/all-classes-short-names
([])
  Returns a map where short classnames are matched with vectors with
  package-qualified classnames.
-------------------------
clojure.core.protocols/IKVReduce
  Protocol for concrete associative types that can reduce themselves
   via a function of key and val faster than first/next recursion over map
   entries. Called by clojure.core/reduce-kv, and has same
   semantics (just different arg order).
-------------------------
clojure.pprint/get-pretty-writer
([writer])
  Returns the java.io.Writer passed in wrapped in a pretty writer proxy, unless it's 
already a pretty writer. Generally, it is unnecessary to call this function, since pprint,
write, and cl-format all call it if they need to. However if you want the state to be 
preserved across calls, you will want to wrap them with this. 

For example, when you want to generate column-aware output with multiple calls to cl-format, 
do it like in this example:

    (defn print-table [aseq column-width]
      (binding [*out* (get-pretty-writer *out*)]
        (doseq [row aseq]
          (doseq [col row]
            (cl-format true "~4D~7,vT" col column-width))
          (prn))))

Now when you run:

    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)

It prints a table of squares and cubes for the numbers from 1 to 10:

       1      1       1    
       2      4       8    
       3      9      27    
       4     16      64    
       5     25     125    
       6     36     216    
       7     49   
  343    
       8     64     512    
       9     81     729    
      10    100    1000
-------------------------
clojure.pprint/map-params
([def params flags offset])
  Takes a directive definition and the list of actual parameters and
a map of flags and returns a map of the parameters and flags with defaults
filled in. We check to make sure that there are the right types and number
of parameters as well.
-------------------------
clojure.pprint/map-ref-type
([name])
  Map ugly type names to something simpler
-------------------------
clojure.pprint/print-table
([ks rows] [rows])
  Prints a collection of maps in a textual table. Prints table headings
   ks, and then a line of output for each row, corresponding to the keys
   in ks. If ks are not specified, use the keys of the first item in rows.
-------------------------
clojure.pprint/tuple-map
([m v1])
  For all the values, v, in the map, replace them with [v v1]
-------------------------
clojure.pprint/unzip-map
([m])
  Take a map that has pairs in the value slots and produce a pair of
  maps, the first having all the first elements of the pairs and the
  second all the second elements of the pairs
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.eldoc/eldoc
([info])
  Generate an eldoc from `info`.

  The result is a map featuring:

  * :ns or :class - depending on whether we're dealing with Clojure or Java symbol
  * :name or :member - depending on whether we're dealing with Clojure or Java symbol
  * :eldoc - a list of type signatures suitable to be displayed by Emacs's eldoc
  * :type - the type of the symbol (e.g. function, variable, special-form)
  * :docstring

  See `cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.info/info` for the structure of the `info`.
-------------------------
nrepl.bencode/write-bencode
  Write the given thing to the output stream. “Thing” means here a
  string, map, sequence or integer. Alternatively an ByteArray may
  be provided whose contents are written as a bytestring. Similar
  the contents of a given InputStream are written as a byte string.
  Named things (symbols or keywords) are written in the form
  'namespace/name'.
-------------------------
cider.nrepl.version/version
  Current version of CIDER nREPL as a map.
  Map of :major, :minor, :incremental, :qualifier,
  and :version-string.
-------------------------
clojure.instant/read-instant-calendar
([cs])
  To read an instant as a java.util.Calendar, bind *data-readers* to a map with
this var as the value for the 'inst key.  Calendar preserves the timezone
offset.
-------------------------
clojure.instant/read-instant-date
([cs])
  To read an instant as a java.util.Date, bind *data-readers* to a map with
this var as the value for the 'inst key. The timezone offset will be used
to convert into UTC.
-------------------------
clojure.instant/read-instant-timestamp
([cs])
  To read an instant as a java.sql.Timestamp, bind *data-readers* to a
map with this var as the value for the 'inst key. Timestamp preserves
fractional seconds with nanosecond precision. The timezone offset will
be used to convert into UTC.
-------------------------
cider.nrepl.inlined-deps.suitable.v0v4v1.suitable.js-completions/cljs-completions
([cljs-eval-fn symbol {:keys [ns context]}])
  Given some context (the toplevel form that has changed) and a symbol string
  that represents the last typed input, we try to find out if the context/symbol
  are object access (property access or method call). If so, we try to extract a
  form that we can evaluate to get the object that is accessed. If we get the
  object, we enumerate it's properties and methods and generate a list of
  matching completions for those.

  The arguments to this function are

  1. `cljs-eval-fn`: a function that given a namespace (as string) and cljs
  code (string) will evaluate it and return the value as a clojure object. See
  `cider.nrepl.inlined-deps.suitable.v0v4v1.suitable.middleware/cljs-dynamic-completion-handler` for how to
  setup an eval function with nREPL.

  The last two arguments mirror the interface of `cider.nrepl.inlined-deps.compliment.v0v3v12.compliment.core/completions`
  from https://github.com/alexander-yakushev/compliment:

  2. A symbol (as string) to complete, basically the prefix.

  3. An options
 map that should have at least the keys :ns and :context. :ns is
  the name (string) of the namespace the completion request is coming
  from. :context is a s-expression (as string) of the toplevel form the symbol
  comes from, the symbol being replaced by "__prefix__". See the compliment
  library for details on this format.
  Currently unsupported options that compliment implements
  are :extra-metadata :sort-order and :plain-candidates.
-------------------------
cider.nrepl.middleware.util.meta/relevant-meta
([m])
  Filter the entries in map m by `relevant-meta-keys` and non-nil values.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.cljs.analysis/imports
([env ns])
  Returns a map of [import-name] to [ns-qualified-import-name] for all imports
  in the given namespace.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.cljs.analysis/macro-ns-aliases
([env ns])
  Returns a map of [macro-ns-name-or-alias] to [macro-ns-name] for the given namespace.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.cljs.analysis/ns-aliases
([env ns])
  Returns a map of [ns-name-or-alias] to [ns-name] for the given namespace.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.cljs.analysis/ns-interns-from-env
([env ns])
  Given a namespace return all the var analysis maps. Analagous to
  clojure.core/ns-interns but returns var analysis maps not vars.

  Directly from cljs.analyzer.api.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.cljs.analysis/public-macros
([env ns])
  Given a namespace return all the public var analysis maps. Analagous to
  clojure.core/ns-publics but returns var analysis maps not vars.

  Inspired by the ns-publics in cljs.analyzer.api.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.cljs.analysis/referred-macros
([env ns])
  Returns a map of [macro-name] to [ns-qualified-macro-name] for all referred
  macros in the given namespace.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.cljs.analysis/referred-vars
([env ns])
  Returns a map of [var-name] to [ns-qualified-var-name] for all referred vars
  in the given namespace.
-------------------------
cider.nrepl.inlined-deps.suitable.v0v4v1.suitable.compliment.sources.cljs/candidate-data
([candidate ns type] [candidate ns type meta extra-metadata])
  Returns a map of candidate data for the given arguments.
-------------------------
cider.nrepl.inlined-deps.suitable.v0v4v1.suitable.compliment.sources.cljs/var->type
([var])
  Returns the candidate type corresponding to the given metadata map.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.java.resource/resource-maps
([])
  Return a seq of resource maps:

    {:file    "the absolute path to the resource"
     :relpath "the path of the resource relative to the classpath"}

  If the project does not contain resources, it returns nil.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.java/resolve-javadoc-path
([path])
  Resolve a relative javadoc path to a URL and return as a map. Prefer javadoc
  resources on the classpath; then use online javadoc content for core API
  classes. If no source is available, return the relative path as is.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.java/resolve-symbol
([ns sym])
  Return the info map for a Java member symbol.

  Constructors and static calls are resolved to the class
  unambiguously. Instance members are resolved unambiguously if defined
  by only one imported class. If multiple imported classes have a member
  by that name, a map of class names to member info is returned as
  `:candidates`.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.inspect/next-page
([inspector])
  Jump to the next page when inspecting a paginated sequence/map. Does nothing
  if already on the last page.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.inspect/prev-page
([inspector])
  Jump to the previous page when inspecting a paginated sequence/map. Does
  nothing if already on the first page.
-------------------------
clojure.java.shell/as-env-strings
([arg])
  Helper so that callers can pass a Clojure map for the :env to sh.
-------------------------
clojure.java.shell/sh
([& args])
  Passes the given strings to Runtime.exec() to launch a sub-process.

  Options are

  :in      may be given followed by any legal input source for
           clojure.java.io/copy, e.g. InputStream, Reader, File, byte[],
           or String, to be fed to the sub-process's stdin.
  :in-enc  option may be given followed by a String, used as a character
           encoding name (for example "UTF-8" or "ISO-8859-1") to
           convert the input string specified by the :in option to the
           sub-process's stdin.  Defaults to UTF-8.
           If the :in option provides a byte array, then the bytes are passed
           unencoded, and this option is ignored.
  :out-enc option may be given followed by :bytes or a String. If a
           String is given, it will be used as a character encoding
           name (for example "UTF-8" or "ISO-8859-1") to convert
           the sub-process's stdout to a String which is returned.
           If :bytes is given, the sub-process's stdout will be stored
           in
 a byte array and returned.  Defaults to UTF-8.
  :env     override the process env with a map (or the underlying Java
           String[] if you are a masochist).
  :dir     override the process dir with a String or java.io.File.

  You can bind :env or :dir for multiple operations using with-sh-env
  and with-sh-dir.

  sh returns a map of
    :exit => sub-process's exit code
    :out  => sub-process's stdout (as byte[] or String)
    :err  => sub-process's stderr (String via platform default encoding)
-------------------------
nrepl.core/combine-responses
([responses])
  Combines the provided seq of response messages into a single response map.

   Certain message slots are combined in special ways:

     - only the last :ns is retained
     - :value is accumulated into an ordered collection
     - :status and :session are accumulated into a set
     - string values (associated with e.g. :out and :err) are concatenated
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.java.parser/markdown
  Syntax map from html tag to a tuple of tag type key, start, and end chars
-------------------------
nrepl.middleware.completion/*complete-fn*
  Function to use for completion. Takes three arguments: `prefix`, the completion prefix,
  `ns`, the namespace in which to look for completions, and `options`, a map of additional
  options for the completion function.
-------------------------
nrepl.middleware.completion/wrap-completion
([h])
  Middleware that provides code completion.
  It understands the following params:

  * `prefix` - the prefix which to complete.
  * `ns`- the namespace in which to do completion. Defaults to `*ns*`.
  * `complete-fn` – a fully-qualified symbol naming a var whose function to use for
  completion. Must point to a function with signature [prefix ns options].
  * `options` – a map of options to pass to the completion function.
-------------------------
incomplete.core/sanitize-meta
([m])
  Sanitize a Clojure metadata map such that it can be bencoded.
-------------------------
cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.track/add
([tracker depmap])
  Returns an updated dependency tracker with new/updated namespaces.

  Depmap is a map describing the new or modified namespaces. Keys in
  the map are namespace names (symbols). Values in the map are sets of
  symbols naming the direct dependencies of each namespace. For
  example, assuming these ns declarations:

      (ns alpha (:require beta))
      (ns beta (:require gamma delta))

  the depmap would look like this:

      {alpha #{beta}
       beta  #{gamma delta}}

  After adding new/updated namespaces, the dependency tracker will
  have two lists associated with the following keys:

      :cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.track/unload
          is the list of namespaces that need to be removed

      :cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.track/load
          is the list of namespaces that need to be reloaded

  To reload namespaces in the correct order, first remove/unload all
  namespaces in the 'unload' list, then (re)load all 
namespaces in the
  'load' list. The cider.nrepl.inlined-deps.toolsnamespace.v1v0v0.clojure.tools.namespace.reload namespace has
  functions to do this.
-------------------------
nrepl.middleware.print/bound-configuration
([])
  Returns a map, suitable for merging into responses handled by this middleware,
  of the currently-bound dynamic vars used for configuration.
-------------------------
nrepl.middleware.print/wrap-print
([handler])
  Middleware that provides printing functionality to other middlewares.

  Returns a handler which transforms any slots specified by
  `:nrepl.middleware.print/keys` in messages sent via the request's transport to
  strings using the provided printing function and options.

  Supports the following options:

  * `::print` – a fully-qualified symbol naming a var whose function to use for
  printing. Must point to a function with signature [value writer options].

  * `::options` – a map of options to pass to the printing function. Defaults to
  `nil`.

  * `::print-fn` – the function to use for printing. In requests, will be
  resolved from the above two options (if provided). Defaults to the equivalent
  of `clojure.core/pr`. Must have signature [writer options].

  * `::stream?` – if logical true, the result of printing each value will be
  streamed to the client over one or more messages.

  * `::buffer-size` – the size of the buffer to use when streaming results.
  Defaults to 1024.

  * `::quota` – a hard
 limit on the number of bytes printed for each value.

  * `::keys` – a seq of the keys in the response whose values should be printed.

  The options may be specified in either the request or the responses sent on
  its transport. If any options are specified in both, those in the request will
  be preferred.
-------------------------
cider.nrepl.middleware.util.instrument/instrument-case-map
([args])
  Instrument the map that is 5th arg in a `case*`.
-------------------------
cider.nrepl.middleware.util.instrument/instrument-tagged-code
([form])
  Return `form` instrumented with breakpoints.
  It is expected that something in `form` will contain a
  ::breakfunction metadata, whose value should be a var holding a macro. This
  macro should take three arguments, the form being evaluated, a map containing
  coordinates vector (see below), and the original form (before macroexpansion).

  This function walks through the code attaching to objects the ::extras
  metadata, which is a map currently containing a :coor vector. The :coor
  specifies its position inside the top-level form. As an example, a coordinate
  vector of [3 2 0] means:
    - enter this sexp and move forward three times,
    - enter this sexp and move forward twice,
    - enter this sexp.

  After that, it fully macroexpands the code, walks through it again, and wraps
  in a ::breakfunction any form that contains the previously attached metadata.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.info
  Retrieve the info map from var and symbols.
-------------------------
clojure.test
  A unit testing framework.

   ASSERTIONS

   The core of the library is the "is" macro, which lets you make
   assertions of any arbitrary expression:

   (is (= 4 (+ 2 2)))
   (is (instance? Integer 256))
   (is (.startsWith "abcde" "ab"))

   You can type an "is" expression directly at the REPL, which will
   print a message if it fails.

       user> (is (= 5 (+ 2 2)))

       FAIL in  (:1)
       expected: (= 5 (+ 2 2))
         actual: (not (= 5 4))
       false

   The "expected:" line shows you the original expression, and the
   "actual:" shows you what actually happened.  In this case, it
   shows that (+ 2 2) returned 4, which is not = to 5.  Finally, the
   "false" on the last line is the value returned from the
   expression.  The "is" macro always returns the result of the
   inner expression.

   There are two special assertions for testing exceptions.  The
   "(is (thrown? c ...))" form tests if an exception of class c is
   thrown:

   (is (thrown? ArithmeticException (/ 1 0))) 

   "(is (th
rown-with-msg? c re ...))" does the same thing and also
   tests that the message on the exception matches the regular
   expression re:

   (is (thrown-with-msg? ArithmeticException #"Divide by zero"
                         (/ 1 0)))

   DOCUMENTING TESTS

   "is" takes an optional second argument, a string describing the
   assertion.  This message will be included in the error report.

   (is (= 5 (+ 2 2)) "Crazy arithmetic")

   In addition, you can document groups of assertions with the
   "testing" macro, which takes a string followed by any number of
   assertions.  The string will be included in failure reports.
   Calls to "testing" may be nested, and all of the strings will be
   joined together with spaces in the final report, in a style
   similar to RSpec <http://rspec.info/>

   (testing "Arithmetic"
     (testing "with positive integers"
       (is (= 4 (+ 2 2)))
       (is (= 7 (+ 3 4))))
     (testing "with negative integers"
       (is (= -4 (+ -2 -2)))
       (is (= -1 (+ 3 -4)))))

   Not
e that, unlike RSpec, the "testing" macro may only be used
   INSIDE a "deftest" or "with-test" form (see below).


   DEFINING TESTS

   There are two ways to define tests.  The "with-test" macro takes
   a defn or def form as its first argument, followed by any number
   of assertions.  The tests will be stored as metadata on the
   definition.

   (with-test
       (defn my-function [x y]
         (+ x y))
     (is (= 4 (my-function 2 2)))
     (is (= 7 (my-function 3 4))))

   As of Clojure SVN rev. 1221, this does not work with defmacro.
   See http://code.google.com/p/clojure/issues/detail?id=51

   The other way lets you define tests separately from the rest of
   your code, even in a different namespace:

   (deftest addition
     (is (= 4 (+ 2 2)))
     (is (= 7 (+ 3 4))))

   (deftest subtraction
     (is (= 1 (- 4 3)))
     (is (= 3 (- 7 4))))

   This creates functions named "addition" and "subtraction", which
   can be called like any other function.  Therefore, tests can be
   grouped and compos
ed, in a style similar to the test framework in
   Peter Seibel's "Practical Common Lisp"
   <http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html>

   (deftest arithmetic
     (addition)
     (subtraction))

   The names of the nested tests will be joined in a list, like
   "(arithmetic addition)", in failure reports.  You can use nested
   tests to set up a context shared by several tests.


   RUNNING TESTS

   Run tests with the function "(run-tests namespaces...)":

   (run-tests 'your.namespace 'some.other.namespace)

   If you don't specify any namespaces, the current namespace is
   used.  To run all tests in all namespaces, use "(run-all-tests)".

   By default, these functions will search for all tests defined in
   a namespace and run them in an undefined order.  However, if you
   are composing tests, as in the "arithmetic" example above, you
   probably do not want the "addition" and "subtraction" tests run
   separately.  In that case, you must define a special function
   named "test-ns-hook" that runs your tests in the correct order:

   (defn test-ns-hook []
     (arithmetic))

   Note: test-ns-hook prevents execution of fixtures (see below).


   OMITTING TESTS FROM PRODUCTION CODE

   You can bind the variable "*load-tests*" to false when loading or
   compiling code in production.  This will prevent any tests from
   being created by "with-test" or "deftest".


   FIXTURES

   Fixtures allow you to run code before and after tests, to set up
   the context in which tests should be run.

   A fixture is just a function that calls another function passed as
   an argument.  It looks like this:

   (defn my-fixture [f]
      Perform setup, establish bindings, whatever.
     (f)  Then call the function we were passed.
      Tear-down / clean-up code here.
    )

   Fixtures are attached to namespaces in one of two ways.  "each"
   fixtures are run repeatedly, once for each test function created
   with "deftest" or "with-test".  "each" fixtures are useful for
   establishin
g a consistent before/after state for each test, like
   clearing out database tables.

   "each" fixtures can be attached to the current namespace like this:
   (use-fixtures :each fixture1 fixture2 ...)
   The fixture1, fixture2 are just functions like the example above.
   They can also be anonymous functions, like this:
   (use-fixtures :each (fn [f] setup... (f) cleanup...))

   The other kind of fixture, a "once" fixture, is only run once,
   around ALL the tests in the namespace.  "once" fixtures are useful
   for tasks that only need to be performed once, like establishing
   database connections, or for time-consuming tasks.

   Attach "once" fixtures to the current namespace like this:
   (use-fixtures :once fixture1 fixture2 ...)

   Note: Fixtures and test-ns-hook are mutually incompatible.  If you
   are using test-ns-hook, fixture functions will *never* be run.


   SAVING TEST OUTPUT TO A FILE

   All the test reporting functions write to the var *test-out*.  By
   default, this is the same as 
*out*, but you can rebind it to any
   PrintWriter.  For example, it could be a file opened with
   clojure.java.io/writer.


   EXTENDING TEST-IS (ADVANCED)

   You can extend the behavior of the "is" macro by defining new
   methods for the "assert-expr" multimethod.  These methods are
   called during expansion of the "is" macro, so they should return
   quoted forms to be evaluated.

   You can plug in your own test-reporting framework by rebinding
   the "report" function: (report event)

   The 'event' argument is a map.  It will always have a :type key,
   whose value will be a keyword signaling the type of event being
   reported.  Standard events with :type value of :pass, :fail, and
   :error are called when an assertion passes, fails, and throws an
   exception, respectively.  In that case, the event will also have
   the following keys:

     :expected   The form that was expected to be true
     :actual     A form representing what actually occurred
     :message    The string message given as an
 argument to 'is'

   The "testing" strings will be a list in "*testing-contexts*", and
   the vars being tested will be a list in "*testing-vars*".

   Your "report" function should wrap any printing calls in the
   "with-test-out" macro, which rebinds *out* to the current value
   of *test-out*.

   For additional event types, see the examples in the code.

-------------------------
cider.nrepl.middleware.util.coerce
  Coercion utilities for coercing bencoded maps.
-------------------------
clojure.reflect
  Reflection on Host Types
Alpha - subject to change.

Two main entry points: 

* type-reflect reflects on something that implements TypeReference.
* reflect (for REPL use) reflects on the class of an instance, or
  on a class if passed a class

Key features:

* Exposes the read side of reflection as pure data. Reflecting
  on a type returns a map with keys :bases, :flags, and :members.

* Canonicalizes class names as Clojure symbols. Types can extend
  to the TypeReference protocol to indicate that they can be
  unambiguously resolved as a type name. The canonical format
  requires one non-Java-ish convention: array brackets are <>
  instead of [] so they can be part of a Clojure symbol.

* Pluggable Reflectors for different implementations. The default
  JavaReflector is good when you have a class in hand, or use
  the AsmReflector for "hands off" reflection without forcing
  classes to load.

Platform implementers must:

* Create an implementation of Reflector.
* Create one or more implementations of TypeR
eference.
* def default-reflector to be an instance that satisfies Reflector.
-------------------------
clojure.walk
  This file defines a generic tree walker for Clojure data
structures.  It takes any data structure (list, vector, map, set,
seq), calls a function on every element, and uses the return value
of the function in place of the original.  This makes it fairly
easy to write recursive search-and-replace functions, as shown in
the examples.

Note: "walk" supports all Clojure data structures EXCEPT maps
created with sorted-map-by.  There is no (obvious) way to retrieve
the sorting function.
-------------------------
cider.nrepl.inlined-deps.compliment.v0v3v12.compliment.sources.ns-mappings
  Completion for vars and classes in the current namespace.
-------------------------
cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.clojuredocs
  Find docs from ClojureDocs and retrieve the result as a map.
nil
clj꞉complex-numbers꞉> 
(r/apropos "sqrt")
()
clj꞉complex-numbers꞉> 
(r/apropos "root")
(cider.nrepl.inlined-deps.orchard.v0v8v0.orchard.namespace/project-root clojure.core/alter-var-root
                                                                        clojure.main/root-cause
                                                                        clojure.repl/root-cause
                                                                        clojure.stacktrace/root-cause
                                                                        clojure.zip/root)
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
; Syntax error reading source at (complex_numbers.clj:10:9).
; Invalid token: Math/
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (NoSuchFieldException) compiling . at (complex_numbers.clj:10:3).
; sq
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:10:3).
; No matching method sqrt found taking 0 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; ERROR in complex-numbers-test/absolute-of-negative-purely-imaginary-number (complex_numbers.clj:55):
; Absolute value of a purely imaginary number with negative imaginary part
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (complex_numbers.clj:55)
; expected:
(= (c/abs [0 -5]) 5.0)
; ERROR in complex-numbers-test/absolute-of-negative-purely-real-number (complex_numbers.clj:45):
; Absolute value of a negative purely real number
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (complex_numbers.clj:45)
; expected:
(= (c/abs [-5 0]) 5.0)
; ERROR in complex-numbers-test/absolute-of-positive-purely-imaginary-number (complex_numbers.clj:50):
; Absolute value of a purely imaginary number with positive imaginary part
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (complex_numbers.clj:50)
; expected:
(= (c/abs [0 5]) 5.0)
; ERROR in complex-numbers-test/absolute-of-positive-purely-real-number (complex_numbers.clj:40):
; Absolute value of a positive purely real number
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (complex_numbers.clj:40)
; expected:
(= (c/abs [5 0]) 5.0)
; ERROR in complex-numbers-test/absolute-of-real-and-imaginary-number (complex_numbers.clj:60):
; Absolute value of a number with real and imaginary part
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (complex_numbers.clj:60)
; expected:
(= (c/abs [3 4]) 5.0)
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
nil
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
nil
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
nil
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 5, failures: 15, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/absolute-of-negative-purely-imaginary-number (complex_numbers_test.clj:55):
; Absolute value of a purely imaginary number with negative imaginary part
; expected:
0.0
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-negative-purely-real-number (complex_numbers_test.clj:45):
; Absolute value of a negative purely real number
; expected:
0.0
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-imaginary-number (complex_numbers_test.clj:50):
; Absolute value of a purely imaginary number with positive imaginary part
; expected:
0.0
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-real-number (complex_numbers_test.clj:40):
; Absolute value of a positive purely real number
; expected:
0.0
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-real-and-imaginary-number (complex_numbers_test.clj:60):
; Absolute value of a number with real and imaginary part
; expected:
0.0
; actual:
5.0
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
nil
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
nil
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
nil
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 20, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
; Syntax error compiling at (complex_numbers.clj:10:17).
; Unable to resolve symbol: M in this context
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error reading source at (complex_numbers.clj:10:23).
; Invalid token: Math/
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:10:17).
; No matching method pow found taking 0 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:10:17).
; No matching method pow found taking 0 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:10:17).
; No matching method pow found taking 1 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/absolute-of-negative-purely-imaginary-number (complex_numbers_test.clj:55):
; Absolute value of a purely imaginary number with negative imaginary part
; expected:
1.0
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-negative-purely-real-number (complex_numbers_test.clj:45):
; Absolute value of a negative purely real number
; expected:
0.1767766952966369
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-imaginary-number (complex_numbers_test.clj:50):
; Absolute value of a purely imaginary number with positive imaginary part
; expected:
1.0
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-real-number (complex_numbers_test.clj:40):
; Absolute value of a positive purely real number
; expected:
5.656854249492381
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-real-and-imaginary-number (complex_numbers_test.clj:60):
; Absolute value of a number with real and imaginary part
; expected:
2.8284271247461903
; actual:
5.0
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
nil
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
nil
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
nil
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 20, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/absolute-of-negative-purely-imaginary-number (complex_numbers_test.clj:55):
; Absolute value of a purely imaginary number with negative imaginary part
; expected:
1.0
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-negative-purely-real-number (complex_numbers_test.clj:45):
; Absolute value of a negative purely real number
; expected:
0.1767766952966369
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-imaginary-number (complex_numbers_test.clj:50):
; Absolute value of a purely imaginary number with positive imaginary part
; expected:
1.0
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-real-number (complex_numbers_test.clj:40):
; Absolute value of a positive purely real number
; expected:
5.656854249492381
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-real-and-imaginary-number (complex_numbers_test.clj:60):
; Absolute value of a number with real and imaginary part
; expected:
2.8284271247461903
; actual:
5.0
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
nil
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
nil
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
nil
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 20, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/absolute-of-negative-purely-imaginary-number (complex_numbers_test.clj:55):
; Absolute value of a purely imaginary number with negative imaginary part
; expected:
1.015504800579495
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-negative-purely-real-number (complex_numbers_test.clj:45):
; Absolute value of a negative purely real number
; expected:
1.015504800579495
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-imaginary-number (complex_numbers_test.clj:50):
; Absolute value of a purely imaginary number with positive imaginary part
; expected:
5.744562646538029
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-real-number (complex_numbers_test.clj:40):
; Absolute value of a positive purely real number
; expected:
5.744562646538029
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-real-and-imaginary-number (complex_numbers_test.clj:60):
; Absolute value of a number with real and imaginary part
; expected:
4.898979485566356
; actual:
5.0
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
nil
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
nil
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
nil
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 20, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/absolute-of-negative-purely-imaginary-number (complex_numbers_test.clj:55):
; Absolute value of a purely imaginary number with negative imaginary part
; expected:
1.015504800579495
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-negative-purely-real-number (complex_numbers_test.clj:45):
; Absolute value of a negative purely real number
; expected:
1.015504800579495
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-imaginary-number (complex_numbers_test.clj:50):
; Absolute value of a purely imaginary number with positive imaginary part
; expected:
5.744562646538029
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-real-number (complex_numbers_test.clj:40):
; Absolute value of a positive purely real number
; expected:
5.744562646538029
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-real-and-imaginary-number (complex_numbers_test.clj:60):
; Absolute value of a number with real and imaginary part
; expected:
4.898979485566356
; actual:
5.0
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
nil
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
nil
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
nil
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 20, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/absolute-of-negative-purely-imaginary-number (complex_numbers_test.clj:55):
; Absolute value of a purely imaginary number with negative imaginary part
; expected:
0.1767766952966369
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-negative-purely-real-number (complex_numbers_test.clj:45):
; Absolute value of a negative purely real number
; expected:
5.0990195135927845
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-imaginary-number (complex_numbers_test.clj:50):
; Absolute value of a purely imaginary number with positive imaginary part
; expected:
5.656854249492381
; actual:
5.0
; FAIL in complex-numbers-test/absolute-of-positive-purely-real-number (complex_numbers_test.clj:40):
; Absolute value of a positive purely real number
; expected:
5.0990195135927845
; actual:
5.0
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
nil
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
nil
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
nil
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 19, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
nil
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
nil
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
nil
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 15, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
nil
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
nil
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
nil
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 15, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
nil
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
nil
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
nil
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 15, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:14:3).
; No matching method pow found taking 1 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:14:3).
; No matching method pow found taking 1 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:14:3).
; No matching method pow found taking 1 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:14:3).
; No matching method pow found taking 1 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:14:3).
; No matching method pow found taking 1 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:14:3).
; No matching method pow found taking 1 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:14:3).
; No matching method pow found taking 1 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
25.0
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
25.0
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
2.0000000000000004
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 15, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:14:3).
; No matching method pow found taking 0 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:14:3).
; No matching method pow found taking 1 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:14:3).
; No matching method pow found taking 1 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:14:3).
; No matching method pow found taking 1 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:14:3).
; No matching method pow found taking 1 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
25.0
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
25.0
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
2.0000000000000004
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 15, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
#'complex-numbers/conjugate
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
25.0
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
25.0
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
2.0000000000000004
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 15, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
; Syntax error (UnsupportedOperationException) compiling at (complex_numbers.clj:15:1).
; nth not supported on this type: Long
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Execution error (UnsupportedOperationException) at complex-numbers/conjugate (complex_numbers.clj:13).
; nth not supported on this type: Long
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
; Syntax error (UnsupportedOperationException) compiling at (complex_numbers.clj:14:1).
; nth not supported on this type: Long
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error (UnsupportedOperationException) compiling at (complex_numbers.clj:14:1).
; nth not supported on this type: Long
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Execution error (UnsupportedOperationException) at complex-numbers/conjugate (complex_numbers.clj:12).
; nth not supported on this type: Long
clj꞉complex-numbers꞉> 
#'complex-numbers/conjugate
clj꞉complex-numbers꞉> 
; Execution error (UnsupportedOperationException) at complex-numbers/eval21979$conjugate (form-init9252250445224228245.clj:13).
; nth not supported on this type: Long
clj꞉complex-numbers꞉> 
; Execution error (UnsupportedOperationException) at complex-numbers/eval21979$conjugate (form-init9252250445224228245.clj:13).
; nth not supported on this type: Long
clj꞉complex-numbers꞉> 
; Execution error (UnsupportedOperationException) at complex-numbers/eval21979$conjugate (form-init9252250445224228245.clj:13).
; nth not supported on this type: Long
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
; Syntax error (UnsupportedOperationException) compiling at (complex_numbers.clj:14:1).
; nth not supported on this type: Long
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
#'complex-numbers/conjugate
clj꞉complex-numbers꞉> 
; Execution error (UnsupportedOperationException) at complex-numbers/eval22302$conjugate (form-init9252250445224228245.clj:13).
; nth not supported on this type: Long
clj꞉complex-numbers꞉> 
; Execution error (UnsupportedOperationException) at complex-numbers/eval22302$conjugate (form-init9252250445224228245.clj:13).
; nth not supported on this type: Long
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
; Syntax error (UnsupportedOperationException) compiling at (complex_numbers.clj:14:1).
; nth not supported on this type: Long
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
0.0
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
25.0
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
25.0
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
2.0000000000000004
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 15, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
25.0
; Running tests for complex-numbers...
clj꞉complex-numbers꞉> 
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
25.0
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
25.0
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
2.0000000000000004
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 15, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
25.0
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers_test.clj
#'complex-numbers-test/divide-numbers-with-real-and-imaginary-part
; Running tests for complex-numbers-test...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
25.0
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
25.0
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
2.0000000000000004
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 15, ns: 1, vars: 26
clj꞉complex-numbers-test꞉> 
; Evaluating file: complex_numbers_test.clj
#'complex-numbers-test/divide-numbers-with-real-and-imaginary-part
; Running tests for complex-numbers-test...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
25.0
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
25.0
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
2.0000000000000004
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 15, ns: 1, vars: 26
clj꞉complex-numbers-test꞉> 
#'complex-numbers/conjugate
clj꞉complex-numbers꞉> 
(complex-numbers/conjugate [5 0])
25.0
clj꞉complex-numbers꞉> 
; Running all project tests…
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
25.0
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
25.0
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
2.0000000000000004
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 15, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers_test.clj
; Syntax error compiling at (complex_numbers_test.clj:62:1).
; No such var: c/conju
; Evaluation of file complex_numbers_test.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers_test.clj
; Syntax error (ArityException) compiling at (complex_numbers_test.clj:62:1).
; Wrong number of args (0) passed to: complex-numbers/conjugate
; Evaluation of file complex_numbers_test.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers_test.clj
#'complex-numbers-test/divide-numbers-with-real-and-imaginary-part
; Running tests for complex-numbers-test...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
25.0
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
25.0
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
2.0000000000000004
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 15, ns: 1, vars: 26
clj꞉complex-numbers-test꞉> 
; Syntax error reading source at (REPL:98:1).
; EOF while reading, starting at line 98
clj꞉complex-numbers-test꞉> 
25.0
clj꞉complex-numbers-test꞉> 
; Evaluating file: complex_numbers.clj
; Syntax error reading source at (complex_numbers.clj:31:1).
; EOF while reading, starting at line 12
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
; Syntax error reading source at (complex_numbers.clj:31:1).
; EOF while reading, starting at line 12
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/conjugate-of-purely-imaginary-number (complex_numbers_test.clj:71):
; Conjugate a purely imaginary number
; expected:
nil
; actual:
[0 -5]
; FAIL in complex-numbers-test/conjugate-of-purely-real-number (complex_numbers_test.clj:66):
; Conjugate a purely real number
; expected:
nil
; actual:
[5 0]
; FAIL in complex-numbers-test/conjugate-of-real-and-imaginary-number (complex_numbers_test.clj:76):
; Conjugate a number with real and imaginary part
; expected:
nil
; actual:
[1 -1]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 15, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
; Syntax error compiling at (complex_numbers.clj:13:6).
; Unable to resolve symbol: ne in this context
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 12, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 12, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 12, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 12, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 12, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 12, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 12, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 12, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 12, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
nil
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
nil
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
nil
; actual:
[3 0]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 12, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/add-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:92):
; Add numbers with real and imaginary part
; expected:
[4]
; actual:
[4 6]
; FAIL in complex-numbers-test/add-purely-imaginary-numbers (complex_numbers_test.clj:87):
; Add purely imaginary numbers
; expected:
[0]
; actual:
[0 3]
; FAIL in complex-numbers-test/add-purely-real-numbers (complex_numbers_test.clj:82):
; Add purely real numbers
; expected:
[3]
; actual:
[3 0]
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 12, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 9, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 9, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 9, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
nil
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
nil
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
nil
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 9, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
[]
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
[]
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
[]
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 9, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; ERROR in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (AFn.java:108):
; Subtract numbers with real and imaginary part
; error: clojure.lang.ArityException: Wrong number of args (0) passed to: clojure.core/- (AFn.java:108)
; expected:
(= (c/sub [1 2] [3 4]) [-2 -2])
; ERROR in complex-numbers-test/subtract-purely-imaginary-numbers (AFn.java:103):
; Subtract purely imaginary numbers
; error: clojure.lang.ArityException: Wrong number of args (0) passed to: clojure.core/- (AFn.java:103)
; expected:
(= (c/sub [0 1] [0 2]) [0 -1])
; ERROR in complex-numbers-test/subtract-purely-real-numbers (AFn.java:98):
; Subtract purely real numbers
; error: clojure.lang.ArityException: Wrong number of args (0) passed to: clojure.core/- (AFn.java:98)
; expected:
(= (c/sub [1 0] [2 0]) [-1 0])
; 26 tests finished, problems found. 😭 errors: 3, failures: 6, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
[-2]
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
[0]
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
[-1]
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 9, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; FAIL in complex-numbers-test/subtract-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:108):
; Subtract numbers with real and imaginary part
; expected:
[-2 ()]
; actual:
[-2 -2]
; FAIL in complex-numbers-test/subtract-purely-imaginary-numbers (complex_numbers_test.clj:103):
; Subtract purely imaginary numbers
; expected:
[0 ()]
; actual:
[0 -1]
; FAIL in complex-numbers-test/subtract-purely-real-numbers (complex_numbers_test.clj:98):
; Subtract purely real numbers
; expected:
[-1 ()]
; actual:
[-1 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 9, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 6, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 6, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
nil
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
nil
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
nil
; actual:
[2 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 6, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
[3]
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
[0]
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
[2]
; actual:
[2 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 6, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
[3]
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
[0]
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
[2]
; actual:
[2 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 6, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
[3 12]
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
[0 0]
; actual:
[-2 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 5, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
[3 8]
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
[0 2]
; actual:
[-2 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 5, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
[3 8]
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
[0 2]
; actual:
[-2 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 5, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
#'complex-numbers/sub
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
[3 8]
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
[0 2]
; actual:
[-2 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 5, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
#'complex-numbers/mul
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
[() 3 8]
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
[() 0 2]
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
[() 2 0]
; actual:
[2 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 6, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; ERROR in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (AFn.java:124):
; Multiply numbers with real and imaginary part
; error: clojure.lang.ArityException: Wrong number of args (0) passed to: clojure.core/- (AFn.java:124)
; expected:
(= (c/mul [1 2] [3 4]) [-5 10])
; ERROR in complex-numbers-test/multiply-purely-imaginary-numbers (AFn.java:119):
; Multiply purely imaginary numbers
; error: clojure.lang.ArityException: Wrong number of args (0) passed to: clojure.core/- (AFn.java:119)
; expected:
(= (c/mul [0 1] [0 2]) [-2 0])
; ERROR in complex-numbers-test/multiply-purely-real-numbers (AFn.java:114):
; Multiply purely real numbers
; error: clojure.lang.ArityException: Wrong number of args (0) passed to: clojure.core/- (AFn.java:114)
; expected:
(= (c/mul [1 0] [2 0]) [2 0])
; 26 tests finished, problems found. 😭 errors: 3, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
[-5]
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
[-2]
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
[2]
; actual:
[2 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 6, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
[-5]
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
[-2]
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
[2]
; actual:
[2 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 6, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
[-5 ()]
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
[-2 ()]
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
[2 ()]
; actual:
[2 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 6, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; ERROR in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (Class.java:124):
; Multiply numbers with real and imaginary part
; error: java.lang.ClassCastException: Cannot cast clojure.lang.PersistentList$EmptyList to java.lang.Number (Class.java:124)
; expected:
(= (c/mul [1 2] [3 4]) [-5 10])
; ERROR in complex-numbers-test/multiply-purely-imaginary-numbers (Class.java:119):
; Multiply purely imaginary numbers
; error: java.lang.ClassCastException: Cannot cast clojure.lang.PersistentList$EmptyList to java.lang.Number (Class.java:119)
; expected:
(= (c/mul [0 1] [0 2]) [-2 0])
; ERROR in complex-numbers-test/multiply-purely-real-numbers (Class.java:114):
; Multiply purely real numbers
; error: java.lang.ClassCastException: Cannot cast clojure.lang.PersistentList$EmptyList to java.lang.Number (Class.java:114)
; expected:
(= (c/mul [1 0] [2 0]) [2 0])
; 26 tests finished, problems found. 😭 errors: 3, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
[-5 6]
; actual:
[-5 10]
; 26 tests finished, problems found. 😭 errors: 0, failures: 4, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/multiply-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:124):
; Multiply numbers with real and imaginary part
; expected:
[-5 7]
; actual:
[-5 10]
; FAIL in complex-numbers-test/multiply-purely-imaginary-numbers (complex_numbers_test.clj:119):
; Multiply purely imaginary numbers
; expected:
[-2 1]
; actual:
[-2 0]
; FAIL in complex-numbers-test/multiply-purely-real-numbers (complex_numbers_test.clj:114):
; Multiply purely real numbers
; expected:
[2 1]
; actual:
[2 0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 6, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
nil
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
nil
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
nil
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; ERROR in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (Numbers.java:140):
; Divide numbers with real and imaginary part
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:140)
; expected:
(= (c/div [1 2] [3 4]) [0.44 0.08])
; ERROR in complex-numbers-test/divide-purely-real-numbers (Numbers.java:130):
; Divide purely real numbers
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:130)
; expected:
(= (c/div [1 0] [2 0]) [0.5 0.0])
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (Numbers.java:135):
; Divide purely imaginary numbers
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 3, failures: 0, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
1/3
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
1/2
; actual:
[0.5 0.0]
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (Numbers.java:135):
; Divide purely imaginary numbers
; error: java.lang.ArithmeticException: Divide by zero (Numbers.java:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 1, failures: 2, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
1/3
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
1/2
; actual:
[0.5 0.0]
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (Numbers.java:135):
; Divide purely imaginary numbers
; error: java.lang.ArithmeticException: Divide by zero (Numbers.java:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 1, failures: 2, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
1/3
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
1/2
; actual:
[0.5 0.0]
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (Numbers.java:135):
; Divide purely imaginary numbers
; error: java.lang.ArithmeticException: Divide by zero (Numbers.java:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 1, failures: 2, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
1/4
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
1/3
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
1
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
1/15
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
1/2
; actual:
[0.5 0.0]
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (Numbers.java:135):
; Divide purely imaginary numbers
; error: java.lang.ArithmeticException: Divide by zero (Numbers.java:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 1, failures: 2, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; ERROR in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (Numbers.java:140):
; Divide numbers with real and imaginary part
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:140)
; expected:
(= (c/div [1 2] [3 4]) [0.44 0.08])
; ERROR in complex-numbers-test/divide-purely-real-numbers (Numbers.java:130):
; Divide purely real numbers
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:130)
; expected:
(= (c/div [1 0] [2 0]) [0.5 0.0])
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (Numbers.java:135):
; Divide purely imaginary numbers
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 3, failures: 0, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; ERROR in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (Numbers.java:140):
; Divide numbers with real and imaginary part
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:140)
; expected:
(= (c/div [1 2] [3 4]) [0.44 0.08])
; ERROR in complex-numbers-test/divide-purely-real-numbers (Numbers.java:130):
; Divide purely real numbers
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:130)
; expected:
(= (c/div [1 0] [2 0]) [0.5 0.0])
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (Numbers.java:135):
; Divide purely imaginary numbers
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 3, failures: 0, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
0.025
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
0.16666666666666666
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
0.25
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; ERROR in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (AFn.java:140):
; Divide numbers with real and imaginary part
; error: clojure.lang.ArityException: Wrong number of args (0) passed to: clojure.core// (AFn.java:140)
; expected:
(= (c/div [1 2] [3 4]) [0.44 0.08])
; ERROR in complex-numbers-test/divide-purely-real-numbers (AFn.java:130):
; Divide purely real numbers
; error: clojure.lang.ArityException: Wrong number of args (0) passed to: clojure.core// (AFn.java:130)
; expected:
(= (c/div [1 0] [2 0]) [0.5 0.0])
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (AFn.java:135):
; Divide purely imaginary numbers
; error: clojure.lang.ArityException: Wrong number of args (0) passed to: clojure.core// (AFn.java:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 3, failures: 0, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
0.025
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
0.16666666666666666
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
0.25
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; ERROR in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (AFn.java:140):
; Divide numbers with real and imaginary part
; error: clojure.lang.ArityException: Wrong number of args (0) passed to: clojure.core// (AFn.java:140)
; expected:
(= (c/div [1 2] [3 4]) [0.44 0.08])
; ERROR in complex-numbers-test/divide-purely-real-numbers (AFn.java:130):
; Divide purely real numbers
; error: clojure.lang.ArityException: Wrong number of args (0) passed to: clojure.core// (AFn.java:130)
; expected:
(= (c/div [1 0] [2 0]) [0.5 0.0])
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (AFn.java:135):
; Divide purely imaginary numbers
; error: clojure.lang.ArityException: Wrong number of args (0) passed to: clojure.core// (AFn.java:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 3, failures: 0, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
0.025
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
0.16666666666666666
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
0.25
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
0.6
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
0.5
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
0.0
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
0.6
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
0.5
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
0.0
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
0.6
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
0.5
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
0.0
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; ERROR in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers.clj:140):
; Divide numbers with real and imaginary part
; error: java.lang.ClassCastException: class java.lang.Double cannot be cast to class clojure.lang.IFn (java.lang.Double is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'app') (complex_numbers.clj:140)
; expected:
(= (c/div [1 2] [3 4]) [0.44 0.08])
; ERROR in complex-numbers-test/divide-purely-real-numbers (complex_numbers.clj:130):
; Divide purely real numbers
; error: java.lang.ClassCastException: class java.lang.Double cannot be cast to class clojure.lang.IFn (java.lang.Double is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'app') (complex_numbers.clj:130)
; expected:
(= (c/div [1 0] [2 0]) [0.5 0.0])
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers.clj:135):
; Divide purely imaginary numbers
; error: java.lang.ClassCastException: class java.lang.Double cannot be cast to class clojure.lang.IFn (java.lang.Double is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'app') (complex_numbers.clj:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 3, failures: 0, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
0.6
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
0.5
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
0.0
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
0.6
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
0.5
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
0.0
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
[0.6]
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
[0.5]
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
[0.0]
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
[0.6]
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
[0.5]
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
[0.0]
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; ERROR in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (AFn.java:140):
; Divide numbers with real and imaginary part
; error: clojure.lang.ArityException: Wrong number of args (0) passed to: clojure.core// (AFn.java:140)
; expected:
(= (c/div [1 2] [3 4]) [0.44 0.08])
; ERROR in complex-numbers-test/divide-purely-real-numbers (AFn.java:130):
; Divide purely real numbers
; error: clojure.lang.ArityException: Wrong number of args (0) passed to: clojure.core// (AFn.java:130)
; expected:
(= (c/div [1 0] [2 0]) [0.5 0.0])
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (AFn.java:135):
; Divide purely imaginary numbers
; error: clojure.lang.ArityException: Wrong number of args (0) passed to: clojure.core// (AFn.java:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 3, failures: 0, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; ERROR in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (Numbers.java:140):
; Divide numbers with real and imaginary part
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:140)
; expected:
(= (c/div [1 2] [3 4]) [0.44 0.08])
; ERROR in complex-numbers-test/divide-purely-real-numbers (Numbers.java:130):
; Divide purely real numbers
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:130)
; expected:
(= (c/div [1 0] [2 0]) [0.5 0.0])
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (Numbers.java:135):
; Divide purely imaginary numbers
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 3, failures: 0, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
[0.6 1/5]
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/divide-purely-real-numbers (complex_numbers_test.clj:130):
; Divide purely real numbers
; expected:
[0.5 -1]
; actual:
[0.5 0.0]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
[0.0 -1]
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 3, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
[0.6 1/2]
; actual:
[0.44 0.08]
; ERROR in complex-numbers-test/divide-purely-real-numbers (Numbers.java:130):
; Divide purely real numbers
; error: java.lang.ArithmeticException: Divide by zero (Numbers.java:130)
; expected:
(= (c/div [1 0] [2 0]) [0.5 0.0])
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (Numbers.java:135):
; Divide purely imaginary numbers
; error: java.lang.ArithmeticException: Divide by zero (Numbers.java:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 2, failures: 1, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; ERROR in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (Numbers.java:140):
; Divide numbers with real and imaginary part
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:140)
; expected:
(= (c/div [1 2] [3 4]) [0.44 0.08])
; ERROR in complex-numbers-test/divide-purely-real-numbers (Numbers.java:130):
; Divide purely real numbers
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:130)
; expected:
(= (c/div [1 0] [2 0]) [0.5 0.0])
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (Numbers.java:135):
; Divide purely imaginary numbers
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 3, failures: 0, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; ERROR in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (Numbers.java:140):
; Divide numbers with real and imaginary part
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:140)
; expected:
(= (c/div [1 2] [3 4]) [0.44 0.08])
; ERROR in complex-numbers-test/divide-purely-real-numbers (Numbers.java:130):
; Divide purely real numbers
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:130)
; expected:
(= (c/div [1 0] [2 0]) [0.5 0.0])
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (Numbers.java:135):
; Divide purely imaginary numbers
; error: java.lang.ClassCastException: class clojure.lang.PersistentList$EmptyList cannot be cast to class java.lang.Number (clojure.lang.PersistentList$EmptyList is in unnamed module of loader 'app'; java.lang.Number is in module java.base of loader 'bootstrap') (Numbers.java:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 3, failures: 0, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
; Syntax error (IllegalArgumentException) compiling . at (complex_numbers.clj:26:30).
; No matching method pow found taking 0 args for class java.lang.Math
; Evaluation of file complex_numbers.clj failed: class clojure.lang.Compiler$CompilerException
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
[0.6 0.2222222222222222]
; actual:
[0.44 0.08]
; ERROR in complex-numbers-test/dividey-purely-imaginary-numbers (Numbers.java:135):
; Divide purely imaginary numbers
; error: java.lang.ArithmeticException: Divide by zero (Numbers.java:135)
; expected:
(= (c/div [0 1] [0 2]) [0.5 0.0])
; 26 tests finished, problems found. 😭 errors: 1, failures: 1, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; FAIL in complex-numbers-test/divide-numbers-with-real-and-imaginary-part (complex_numbers_test.clj:140):
; Divide numbers with real and imaginary part
; expected:
[0.6 0.08]
; actual:
[0.44 0.08]
; FAIL in complex-numbers-test/dividey-purely-imaginary-numbers (complex_numbers_test.clj:135):
; Divide purely imaginary numbers
; expected:
[0.0 0.0]
; actual:
[0.5 0.0]
; 26 tests finished, problems found. 😭 errors: 0, failures: 2, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
; Evaluating file: complex_numbers.clj
#'complex-numbers/div
; Running tests for complex-numbers...
; 26 tests finished, all passing 👍, ns: 1, vars: 26
clj꞉complex-numbers꞉> 
